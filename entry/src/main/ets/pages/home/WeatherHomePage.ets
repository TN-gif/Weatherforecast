import type common from '@ohos.app.ability.common';
import { CityRepository } from '../../data/repository/CityRepository';
import { WeatherRepository } from '../../data/repository/WeatherRepository';
import { WeatherService } from '../../data/services/WeatherService';
import { MockWeatherRepository } from '../../mock/MockWeatherRepository';
import { WeatherController, CityWeatherState } from '../../viewmodel/WeatherController';
import { WeatherSnapshot, City, CitySource } from '../../data/models/WeatherModels';
import { WeatherApiConstants } from '../../common/constants/WeatherApiConstants';
import { AppContextHolder } from '../../common/di/AppContextHolder';
import { AtmosphereBackground } from '../../components/background/AtmosphereBackground';
import { BackgroundMode } from '../../common/constants/ThemeConstants';
import { DebugLogger, LogData } from '../../common/utils/DebugLogger';
import { FeatureChecker, FeatureStatus } from '../../common/utils/FeatureChecker';
import { CityWeatherCard } from '../../components/cards/CityWeatherCard';
import { WeatherDetailGrid } from '../../components/cards/WeatherDetailGrid';
import { AdviceList } from '../../components/cards/AdviceList';
import { FormatHelper } from '../../common/utils/FormatHelper';
import { LocationService } from '../../data/services/LocationService';
import { AppPreferences } from '../../data/storage/AppPreferences';
import { RefreshState } from '../../data/models/WeatherModels';
import { ErrorToast, ErrorMessage, ErrorHandler } from '../../components/common/ErrorToast';
import { ShakeDetector } from '../../common/utils/ShakeDetector';
import { HourlyTrendChart } from '../../components/charts/HourlyTrendChart';
import { PerformanceOverlay } from '../../components/debug/PerformanceOverlay';
import { ResourceStatusOverlay } from '../../components/debug/ResourceStatusOverlay';
import { DatabaseInspector } from '../../components/debug/DatabaseInspector';
import { ChartPerformanceMonitor } from '../../components/debug/ChartPerformanceMonitor';
import { ThemeDebugPanel } from '../../components/debug/ThemeDebugPanel';
import { ResourceValidator } from '../../components/debug/ResourceValidator';
import { LogViewer } from '../../components/debug/LogViewer';
import { NetworkDiagnosis, DiagnosisResult } from '../../common/utils/NetworkDiagnosis';
import { NetworkDiagnosisDialog } from '../../components/diagnosis/NetworkDiagnosisDialog';
import { ResourceManager } from '../../common/utils/ResourceManager';
import { ThemeConstants } from '../../common/constants/ThemeConstants';
import { ThemeManager } from '../../common/theme/ThemeManager';
import router from '@ohos.router';
import { DesignSystem } from '../../common/theme/DesignSystem';
import { WeatherSkeleton } from '../../components/common/WeatherSkeleton';
import vibrator from '@ohos.vibrator';

@Component
export struct WeatherHomePage {
  private preferences: AppPreferences = new AppPreferences();
  private controller: WeatherController = new WeatherController(
    CityRepository.getInstance(),
    new WeatherRepository(new WeatherService(WeatherApiConstants.OPEN_METEO_CONFIG), new MockWeatherRepository()),
    LocationService.getInstance(),
    this.preferences
  );
  private shakeDetector: ShakeDetector = ShakeDetector.getInstance();
  @State private cityStates: CityWeatherState[] = [];
  @State private isLoading: boolean = true;
  @State private errorMessage: string = '';
  @StorageProp('themeKey') themeKey: string = 'sunny_day';
  @State private activeIndex: number = 0;
  @State private isRefreshing: boolean = false;
  @State private refreshState: RefreshState = RefreshState.IDLE;
  @State private shakeEnabled: boolean = true;
  @State private currentError: ErrorMessage | null = null;
  @State private showMenu: boolean = false;
  @State private showDiagnosisDialog: boolean = false;
  @State private diagnosisResult: DiagnosisResult | undefined = undefined;
  private networkDiagnosis: NetworkDiagnosis = NetworkDiagnosis.getInstance();
  private logger: DebugLogger = DebugLogger.getInstance();
  private featureChecker: FeatureChecker = FeatureChecker.getInstance();
  private resourceManager: ResourceManager = ResourceManager.getInstance();
  private themeManager: ThemeManager = ThemeManager.getInstance();
  private diagnosisDialogController?: CustomDialogController;

  aboutToAppear(): void {
    const lifecycleData: LogData = {
      'cityStatesLength': this.cityStates.length,
      'isLoading': this.isLoading,
      'hasError': !!this.currentError
    };
    this.logger.lifecycle('WeatherHomePage', 'aboutToAppear å¼€å§‹', lifecycleData);
    
    // æ‰§è¡ŒåŠŸèƒ½æ£€æŸ¥
    this.performFeatureCheck();
    
    const context: common.UIAbilityContext | null = AppContextHolder.getContext();
    if (context !== null) {
      this.logger.info('WeatherHomePage', 'âœ… Contextè·å–æˆåŠŸï¼Œå¼€å§‹å¯åŠ¨');
      this.bootstrap(context);
      this.initializeShakeDetection();
    } else {
      this.logger.error('WeatherHomePage', 'âŒ Contextè·å–å¤±è´¥');
      this.errorMessage = 'æ— æ³•è·å–åº”ç”¨ä¸Šä¸‹æ–‡';
      this.isLoading = false;
    }
  }

  aboutToDisappear(): void {
    this.logger.lifecycle('WeatherHomePage', 'aboutToDisappear å¼€å§‹');
    // åœæ­¢æ‘‡ä¸€æ‘‡æ£€æµ‹
    this.shakeDetector.stopDetection(() => this.handleShakeRefresh());
  }

  private async bootstrap(context: common.UIAbilityContext): Promise<void> {
    try {
      console.info('[WeatherHomePage] ========== å¼€å§‹åº”ç”¨åˆå§‹åŒ– ==========');
      console.info(`[WeatherHomePage] ğŸ—ï¸ åº”ç”¨ä¸Šä¸‹æ–‡: ${context ? 'æœ‰æ•ˆ' : 'æ— æ•ˆ'}`);
      
      // æ£€æŸ¥ç½‘ç»œçŠ¶æ€
      try {
        console.info('[WeatherHomePage] ğŸŒ æ£€æŸ¥ç½‘ç»œè¿é€šæ€§...');
        const testUrl = 'https://www.baidu.com';
        console.info(`[WeatherHomePage] ğŸ”— æµ‹è¯•URL: ${testUrl}`);
      } catch (networkError) {
        console.warn('[WeatherHomePage] âŒ ç½‘ç»œè¿é€šæ€§æ£€æŸ¥å¤±è´¥:', networkError);
      }
      
      // åˆå§‹åŒ–èµ„æºç®¡ç†å™¨
      console.info('[WeatherHomePage] ğŸ¨ å¼€å§‹åˆå§‹åŒ–èµ„æºç®¡ç†å™¨...');
      await this.resourceManager.init(context);
      console.info('[WeatherHomePage] âœ… èµ„æºç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆ');
      
      // åˆå§‹åŒ–ä¸»é¢˜ç®¡ç†å™¨
      console.info('[WeatherHomePage] ğŸŒ™ å¼€å§‹åˆå§‹åŒ–ä¸»é¢˜ç®¡ç†å™¨...');
      await this.themeManager.init();
      console.info('[WeatherHomePage] âœ… ä¸»é¢˜ç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆ');
      
      // åˆå§‹åŒ–æ§åˆ¶å™¨ï¼ˆåŒ…å«è‡ªåŠ¨å®šä½ï¼‰
      console.info('[WeatherHomePage] ğŸ® å¼€å§‹åˆå§‹åŒ–æ§åˆ¶å™¨...');
      await this.controller.init(context);
      console.info('[WeatherHomePage] âœ… æ§åˆ¶å™¨åˆå§‹åŒ–å®Œæˆ');
      
      // æ£€æŸ¥åˆå§‹åŒ–åçš„åŸå¸‚æ•°æ®
      const cities = this.controller.getCityStates();
      console.info(`[WeatherHomePage] ğŸ“Š åˆå§‹åŒ–ååŸå¸‚æ•°é‡: ${cities.length}`);
      cities.forEach((state, index) => {
        console.info(`[WeatherHomePage] ğŸ™ï¸ åŸå¸‚${index + 1}: ${state.city.name} (${state.city.source})`);
      });
      
      // è·å–èƒŒæ™¯æ¨¡å¼è®¾ç½®
      console.info('[WeatherHomePage] ğŸ¨ åŠ è½½èƒŒæ™¯æ¨¡å¼è®¾ç½®...');
      const backgroundMode: string = await this.preferences.getBackgroundMode();
      AppStorage.setOrCreate('backgroundMode', backgroundMode);
      console.info(`[WeatherHomePage] ğŸ¨ èƒŒæ™¯æ¨¡å¼: ${backgroundMode}`);
      
      // åŠ è½½å¤©æ°”æ•°æ®
      console.info('[WeatherHomePage] ğŸŒ¤ï¸ å¼€å§‹åŠ è½½å¤©æ°”æ•°æ®...');
      await this.refresh(false);
      
      console.info('[WeatherHomePage] ========== åº”ç”¨åˆå§‹åŒ–å®Œæˆ ==========');
    } catch (error) {
      console.error('[WeatherHomePage] Bootstrap failed:', error);
      this.currentError = ErrorHandler.handle(error as Error, 'åº”ç”¨åˆå§‹åŒ–å¤±è´¥');
      this.errorMessage = `åˆå§‹åŒ–å¤±è´¥: ${(error as Error).message}`;
      this.isLoading = false;
    }
  }

  private async refresh(force: boolean): Promise<void> {
    if (this.isRefreshing) {
      console.warn(`[WeatherHomePage] â¸ï¸ åˆ·æ–°å·²åœ¨è¿›è¡Œä¸­ï¼Œå¿½ç•¥æ–°çš„åˆ·æ–°è¯·æ±‚`);
      return;
    }
    
    console.info(`[WeatherHomePage] ========== å¼€å§‹åˆ·æ–°å¤©æ°”æ•°æ® ==========`);
    console.info(`[WeatherHomePage] ğŸ”„ å¼ºåˆ¶åˆ·æ–°: ${force}`);
    console.info(`[WeatherHomePage] ğŸ“Š å½“å‰åŸå¸‚æ•°é‡: ${this.cityStates.length}`);
    console.info(`[WeatherHomePage] ğŸ‘† å½“å‰æ´»åŠ¨ç´¢å¼•: ${this.activeIndex}`);
    
    // æ˜¾ç¤ºå½“å‰åŸå¸‚çŠ¶æ€
    this.cityStates.forEach((state, index) => {
      console.info(`[WeatherHomePage] ğŸ™ï¸ åŸå¸‚${index + 1}: ${state.city.name} (ID: ${state.city.id}, æ¥æº: ${state.city.source})`);
    });
    
    this.isRefreshing = true;
    this.refreshState = RefreshState.REFRESHING;
    try {
      const states: CityWeatherState[] = await this.controller.loadAll(force);
      console.info(`[WeatherHomePage] Loaded ${states.length} city states`);
      
      // è¿‡æ»¤æ‰æ— æ•ˆçš„çŠ¶æ€
      const validStates = states.filter(state => state && state.city && state.city.id);
      console.info(`[WeatherHomePage] Valid states: ${validStates.length}`);
      
      this.cityStates = validStates;
      this.errorMessage = '';
      
      if (this.activeIndex >= validStates.length) {
        this.activeIndex = 0;
      }
      
      console.info('[WeatherHomePage] Refresh completed successfully');
    } catch (error) {
      console.error('[WeatherHomePage] Refresh failed:', error);
      this.currentError = ErrorHandler.createNetworkError('å¤©æ°”æ•°æ®åˆ·æ–°å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•');
      this.errorMessage = `å¤©æ°”æœåŠ¡æš‚ä¸å¯ç”¨: ${(error as Error).message}`;
    } finally {
      this.isLoading = false;
      this.isRefreshing = false;
      this.refreshState = RefreshState.IDLE;
      console.info('[WeatherHomePage] Refresh process completed');
    }
  }

  private async handleRefresh(): Promise<void> {
    await this.refresh(true);
  }

  private initializeShakeDetection(): void {
    if (this.shakeEnabled) {
      const success = this.shakeDetector.startDetection(() => this.handleShakeRefresh());
      if (!success) {
        console.warn('[WeatherHomePage] Failed to initialize shake detection');
        this.shakeEnabled = false;
      }
    }
  }

  private async handleShakeRefresh(): Promise<void> {
    if (this.isRefreshing || this.isLoading) {
      return;
    }
    
    console.info('[WeatherHomePage] Shake refresh triggered');
    
    // å¯é€‰ï¼šæ·»åŠ éœ‡åŠ¨åé¦ˆ
    try {
      // æ³¨æ„ï¼šéœ€è¦æ·»åŠ éœ‡åŠ¨æƒé™æ‰èƒ½ä½¿ç”¨
      // vibrator.startVibration({ type: 'time', duration: 200 });
    } catch (error) {
      // å¿½ç•¥éœ‡åŠ¨é”™è¯¯
    }
    
    await this.refresh(true);
  }

  private get currentState(): CityWeatherState | null {
    if (this.cityStates.length === 0) {
      return null;
    }
    const safeIndex: number = Math.min(this.activeIndex, this.cityStates.length - 1);
    const state = this.cityStates[safeIndex];
    // ç¡®ä¿è¿”å›çš„çŠ¶æ€æ˜¯æœ‰æ•ˆçš„
    if (state && state.city && state.city.id) {
      return state;
    }
    return null;
  }

  private resolveThemeKey(): string {
    if (!this.currentState || !this.currentState.snapshot) {
      return this.isNightTime() ? 'night' : 'sunny';
    }

    const condition = this.currentState.snapshot.current.condition;
    const isNight = this.isNightTime();
    
    // ä¼˜å…ˆä½¿ç”¨conditionä¸­çš„themeKeyï¼Œç„¶åæ ¹æ®æ—¶é—´è°ƒæ•´
    let baseTheme = condition.themeKey;
    
    // æ ¹æ®æ—¶é—´è°ƒæ•´ä¸»é¢˜
    if (baseTheme === 'rainy') {
      return isNight ? 'rainy_night' : 'rainy_day';
    } else if (baseTheme === 'snow') {
      return isNight ? 'snow_night' : 'snow_day';
    } else if (baseTheme === 'sunny') {
      return isNight ? 'night' : 'sunny';
    } else {
      return isNight ? 'night' : 'sunny';
    }
  }

  private isNightTime(): boolean {
    const now = new Date();
    const hours = now.getHours();
    return hours >= 18 || hours <= 6;
  }

  private performFeatureCheck(): void {
    this.logger.info('WeatherHomePage', 'ğŸ” å¼€å§‹æ‰§è¡ŒåŠŸèƒ½æ£€æŸ¥');
    
    const features: FeatureStatus[] = this.featureChecker.checkAllFeatures();
    
    features.forEach((feature: FeatureStatus) => {
      const featureData: LogData = {
        'reason': feature.reason,
        'enabled': feature.enabled
      };
      this.logger.checkFeature('WeatherHomePage', feature.name, feature.enabled, featureData);
    });
    
    const enabledCount = features.filter(f => f.enabled).length;
    const totalCount = features.length;
    
    const enabledFeatureNames = features.filter(f => f.enabled).map(f => f.name).join(', ');
    const disabledFeatureNames = features.filter(f => !f.enabled).map(f => f.name).join(', ');
    
    const summaryData: LogData = {
      'enabledFeatures': enabledFeatureNames,
      'disabledFeatures': disabledFeatureNames,
      'enabledCount': enabledCount,
      'totalCount': totalCount
    };
    
    this.logger.info('WeatherHomePage', `ğŸ“Š åŠŸèƒ½æ£€æŸ¥å®Œæˆ: ${enabledCount}/${totalCount} ä¸ªåŠŸèƒ½å¯ç”¨`, summaryData);
  }

  @Builder
  private renderBackgroundModeSwitch(): void {
    Row() {
      Button('è§†é¢‘èƒŒæ™¯')
        .onClick(() => {
          AppStorage.setOrCreate('backgroundMode', BackgroundMode.VIDEO);
          console.info('[WeatherHomePage] ğŸ¬ åˆ‡æ¢åˆ°è§†é¢‘èƒŒæ™¯æ¨¡å¼');
        })
        .fontSize(12)
        .height(32)
        .backgroundColor('rgba(76, 175, 80, 0.8)')
        .margin({ right: 8 });
      
      Button('åŠ¨ç”»èƒŒæ™¯')
        .onClick(() => {
          AppStorage.setOrCreate('backgroundMode', BackgroundMode.ANIMATED_IMAGE);
          console.info('[WeatherHomePage] ğŸï¸ åˆ‡æ¢åˆ°åŠ¨ç”»èƒŒæ™¯æ¨¡å¼');
        })
        .fontSize(12)
        .height(32)
        .backgroundColor('rgba(33, 150, 243, 0.8)')
        .margin({ right: 8 });
      
      Button('æ¸å˜èƒŒæ™¯')
        .onClick(() => {
          AppStorage.setOrCreate('backgroundMode', BackgroundMode.GRADIENT);
          console.info('[WeatherHomePage] ğŸŒˆ åˆ‡æ¢åˆ°æ¸å˜èƒŒæ™¯æ¨¡å¼');
        })
        .fontSize(12)
        .height(32)
        .backgroundColor('rgba(156, 39, 176, 0.8)');
    }
    .position({ x: 16, y: 100 })
    .zIndex(1000);
  }

  build() {
    Stack() {
      // 1. èƒŒæ™¯å±‚
      AtmosphereBackground()

      // 2. é®ç½©å±‚ï¼šå¢åŠ ä¸€ç‚¹ç‚¹æ¸å˜ï¼Œè®©åº•éƒ¨æ–‡å­—æ›´æ¸…æ™°
      // å…¨å±€å‹æš—
      Rect()
        .width('100%')
        .height('100%')
        .fill(Color.Black)
        .opacity(0.3) // ä¿æŒ 0.3ï¼Œå¤ªé»‘äº†ä¸å¥½çœ‹
        .hitTestBehavior(HitTestMode.None)
      
      // åº•éƒ¨æ¸å˜é®ç½©ï¼ˆå¯é€‰ï¼Œå¢åŠ  Grid åŒºåŸŸçš„å¯è¯»æ€§ï¼‰
      Column()
        .width('100%')
        .height('50%')
        .linearGradient({
          angle: 180,
          colors: [['rgba(0,0,0,0)', 0], ['rgba(0,0,0,0.2)', 1]]
        })
        .position({ y: '50%' })
        .hitTestBehavior(HitTestMode.None)

      // 3. å†…å®¹å±‚
      if (this.isLoading) {
        WeatherSkeleton();
      } else if (this.errorMessage !== '') {
        this.renderError();
      } else {
        this.renderContent();
      }

      // Error Toast
      ErrorToast({ errorMessage: $currentError });
    }
    .width('100%')
    .height('100%')
  }

  @Builder
  private renderContent(): void {
    Refresh({ refreshing: $$this.isRefreshing, builder: this.refreshBuilder }) {
      Column() {
        this.renderHeader();
        this.renderBody();
      }
      .width('100%')
      .height('100%')
    }
    .onRefreshing(() => {
      this.handleRefresh();
    })
  }

  @Builder
  private renderHeader(): void {
    Row() {
      // Left: Menu Button (Icon only)
      this.IconButton(DesignSystem.Icons.MENU, () => this.navigateToCityManagement());

      Blank();

      // Right: Add Button (Icon only)
      this.IconButton(DesignSystem.Icons.PLUS, () => this.navigateToCityManagement());
    }
    .width('100%')
    .padding({ 
      left: DesignSystem.Spacing.L, 
      right: DesignSystem.Spacing.L, 
      top: DesignSystem.Spacing.XL 
    })
  }

  @Builder
  private IconButton(iconPath: string, action: () => void): void {
    Button() {
      Path()
        .commands(iconPath)
        .fill(DesignSystem.Colors.WHITE)
        .width(24)
        .height(24)
        .shadow({ radius: 4, color: 'rgba(0,0,0,0.2)', offsetY: 2 })
    }
    .width(44)
    .height(44)
    .backgroundColor(Color.Transparent) // No background
    .type(ButtonType.Circle) // Ensure circle touch area
    .onClick(() => {
      try {
        vibrator.startVibration({ type: 'time', duration: 50 }, { id: 0, usage: 'touch' });
      } catch (e) {
        // Ignore if vibration not supported
      }
      action();
    })
  }

  @Builder
  private renderBody(): void {
    Column() {
      this.renderSwiper();
    }
    .width('100%')
    .layoutWeight(1)
  }

  @Builder
  private renderSwiper(): void {
    if (this.cityStates.length === 0) {
      Column() {
        // City Name (Left)
        Text(this.getDisplayCityName(this.currentState?.city?.name))
          .fontSize(24)
          .fontWeight(DesignSystem.FontWeight.BOLD)
          .fontColor(DesignSystem.Colors.WHITE);
        Button('æ·»åŠ åŸå¸‚')
          .onClick(() => this.navigateToCityManagement())
          .margin({ top: 16 });
      }
      .width('100%')
      .height('100%')
      .justifyContent(FlexAlign.Center);
    } else {
      Swiper() {
        ForEach(this.cityStates.filter(state => state && state.city && state.city.id), (state: CityWeatherState) => {
          Scroll() {
            Column() {
              // Top Area
              CityWeatherCard({ 
                cityState: state, 
                isActive: this.isStateActive(state) 
              });
              
              // Bottom Area
              Column({ space: 12 }) { // å‡å°å¡ç‰‡é—´çš„å‚ç›´é—´è·
                // Hourly Forecast
                if (state.snapshot && state.snapshot.hourly.length > 0) {
                  HourlyTrendChart({ hourlyData: state.snapshot.hourly });
                }
                
                // Details Grid
                if (state.snapshot) {
                  WeatherDetailGrid({
                    humidity: FormatHelper.formatHumidity(state.snapshot.current.humidity),
                    aqi: FormatHelper.formatAqi(state.snapshot.current.aqi),
                    wind: FormatHelper.formatWind(state.snapshot.current.windSpeedKph, state.snapshot.current.windDirection),
                    feelsLike: FormatHelper.formatTemperature(state.snapshot.current.feelsLikeC),
                    pressure: `${state.snapshot.current.pressureHpa}hPa`,
                    visibilityInfo: `${state.snapshot.current.visibilityKm}`, // Removed 'km' here, added in Grid logic
                    uvIndex: `${state.snapshot.current.uvIndex}`
                  });
                }

                // Advice List
                if (state.snapshot && state.snapshot.advice.length > 0) {
                  AdviceList({ items: state.snapshot.advice });
                }
                
                Blank().height(100); // åº•éƒ¨ç•™ç™½
              }
              .padding({ left: 16, right: 16 }) // ä¿æŒå·¦å³é—´è·
            }
            .width('100%')
            // ç¡®ä¿å†…å®¹è‡³å°‘æœ‰ä¸€å±é«˜ï¼Œä¿è¯å¯ä»¥æ»šåŠ¨ï¼Œäº§ç”Ÿå›å¼¹æ•ˆæœ
            .constraintSize({ minHeight: '100%' }) 
          }
          .scrollBar(BarState.Off)
          .edgeEffect(EdgeEffect.Spring) // å…³é”®ï¼šiOS é£æ ¼çš„å›å¼¹
          .width('100%')
          .height('100%')
        }, (state: CityWeatherState) => state?.city?.id || `city_${Math.random()}`);
      }
      .loop(false)
      .vertical(false)
      .index(this.activeIndex)
      .indicator(false) // Hide default indicator
      .onChange((index: number) => {
        this.activeIndex = index;
      })
      .width('100%')
      .height('100%');

      // Custom Indicator
      Row({ space: 8 }) {
        ForEach(this.cityStates.filter(state => state && state.city && state.city.id), (state: CityWeatherState, index: number) => {
          Column()
            .width(this.isIndexActive(index) ? 8 : 6)
            .height(this.isIndexActive(index) ? 8 : 6)
            .backgroundColor(this.isIndexActive(index) ? DesignSystem.Colors.WHITE : 'rgba(255,255,255,0.4)')
            .borderRadius(4);
        }, (state: CityWeatherState) => state?.city?.id || `indicator_${Math.random()}`);
      }
      .margin({ top: 0 }) // Adjust position if needed, maybe overlay?
      .position({ x: '50%', y: '95%' }) // Position at bottom
      .translate({ x: '-50%' });
    }
  }

  @Builder
  private renderError(): void {
    Column() {
      Text(this.errorMessage)
        .fontSize(18)
        .fontColor('#FFB2B2')
        .margin({ bottom: 16 });
      Button('é‡è¯•')
        .onClick(() => this.refresh(true));
    }
    .width('100%')
    .height('100%')
    .justifyContent(FlexAlign.Center)
    .alignItems(HorizontalAlign.Center);
  }

  @Builder
  private refreshBuilder(): void {
    Row() {
      LoadingProgress()
        .width(24)
        .height(24)
        .color(DesignSystem.Colors.WHITE);
      Text('åˆ·æ–°ä¸­...')
        .fontSize(14)
        .fontColor(DesignSystem.Colors.WHITE_70)
        .margin({ left: DesignSystem.Spacing.S });
    }
    .width('100%')
    .height(60)
    .justifyContent(FlexAlign.Center)
  }

  private isStateActive(state: CityWeatherState): boolean {
    if (!this.currentState || !state?.city?.id || !this.currentState?.city?.id) {
      return false;
    }
    return state.city.id === this.currentState.city.id;
  }

  private isIndexActive(index: number): boolean {
    return index === this.activeIndex;
  }

  private getDisplayCityName(name: string | undefined): string {
    if (!name) return 'Loading...';
    // Simple check if name looks like coordinates (contains numbers and comma)
    if (name.match(/-?\d+(\.\d+)?,\s*-?\d+(\.\d+)?/)) {
      return 'åŒ—äº¬å¸‚'; // Fallback/Mock as requested
    }
    return name;
  }

  private async performNetworkDiagnosis(): Promise<void> {
    try {
      console.info('[WeatherHomePage] Starting network diagnosis...');
      this.currentError = ErrorHandler.createInfoMessage('æ­£åœ¨è¿›è¡Œç½‘ç»œè¯Šæ–­...');
      
      const result = await this.networkDiagnosis.performFullDiagnosis();
      const score = this.networkDiagnosis.getNetworkQualityScore(result);
      
      // æ›´æ–°è¯Šæ–­ç»“æœ
      this.diagnosisResult = result;
      
      // é‡æ–°åˆ›å»ºå¯¹è¯æ¡†æ§åˆ¶å™¨
      this.diagnosisDialogController = new CustomDialogController({
        builder: NetworkDiagnosisDialog({
          diagnosisResult: this.diagnosisResult,
          networkScore: score,
          issues: this.networkDiagnosis.analyzeResults(result)
        }),
        autoCancel: true,
        alignment: DialogAlignment.Center
      });
      
      // æ˜¾ç¤ºè¯Šæ–­å¯¹è¯æ¡†
      if (this.diagnosisDialogController) {
        this.diagnosisDialogController.open();
      }
      
      this.currentError = ErrorHandler.createInfoMessage(`ç½‘ç»œè¯Šæ–­å®Œæˆ (è¯„åˆ†: ${score}/100)`);
      console.info('[WeatherHomePage] Network diagnosis completed:', result);
    } catch (error) {
      console.error('[WeatherHomePage] Network diagnosis failed:', error);
      this.currentError = ErrorHandler.handle(error as Error, 'ç½‘ç»œè¯Šæ–­å¤±è´¥');
    }
  }

  private async forceLocationRefresh(): Promise<void> {
    try {
      console.info('[WeatherHomePage] ========== å¼ºåˆ¶å®šä½åˆ·æ–° ==========');
      this.currentError = ErrorHandler.createInfoMessage('æ­£åœ¨å¼ºåˆ¶åˆ·æ–°å®šä½...');
      
      // æ¸…é™¤ç°æœ‰çš„è‡ªåŠ¨å®šä½åŸå¸‚
      const cities = this.controller.getCityStates();
      const nonAutoCities = cities.filter(state => state.city.source !== CitySource.AUTO);
      console.info(`[WeatherHomePage] ğŸ—‘ï¸ æ¸…é™¤è‡ªåŠ¨å®šä½åŸå¸‚ï¼Œä¿ç•™ ${nonAutoCities.length} ä¸ªæ‰‹åŠ¨åŸå¸‚`);
      
      // å¼ºåˆ¶é‡æ–°è·å–ä½ç½®
      console.info('[WeatherHomePage] ğŸ¯ å¼€å§‹å¼ºåˆ¶å®šä½...');
      const coordinates = await LocationService.getInstance().getCurrentLocation();
      console.info(`[WeatherHomePage] âœ… å¼ºåˆ¶å®šä½æˆåŠŸ: ${coordinates.latitude}, ${coordinates.longitude}`);
      
      // è·å–åŸå¸‚åç§°
      const cityName = await LocationService.getInstance().getCityNameFromCoordinates(coordinates);
      console.info(`[WeatherHomePage] ğŸ™ï¸ åŸå¸‚åç§°: ${cityName}`);
      
      // åˆ›å»ºæ–°çš„è‡ªåŠ¨å®šä½åŸå¸‚
      const newAutoCity = new City(
        `auto_${Math.round(coordinates.latitude * 1000)}_${Math.round(coordinates.longitude * 1000)}`,
        cityName,
        'Auto',
        coordinates,
        CitySource.AUTO,
        'sunny',
        0
      );
      
      console.info(`[WeatherHomePage] ğŸ“ æ–°å»ºè‡ªåŠ¨åŸå¸‚: ${newAutoCity.name} (${newAutoCity.id})`);
      
      // æ›´æ–°åŸå¸‚åˆ—è¡¨
      const updatedCities = [newAutoCity, ...nonAutoCities.map(state => state.city)];
      await CityRepository.getInstance().updateCities(updatedCities);
      
      // åˆ·æ–°ç•Œé¢
      await this.refresh(true);
      
      this.currentError = ErrorHandler.createInfoMessage(`å®šä½åˆ·æ–°å®Œæˆ: ${cityName}`);
      console.info('[WeatherHomePage] ========== å¼ºåˆ¶å®šä½åˆ·æ–°å®Œæˆ ==========');
    } catch (error) {
      console.error('[WeatherHomePage] å¼ºåˆ¶å®šä½åˆ·æ–°å¤±è´¥:', error);
      this.currentError = ErrorHandler.handle(error as Error, 'å¼ºåˆ¶å®šä½åˆ·æ–°å¤±è´¥');
    }
  }

  private async refreshCurrentLocation(): Promise<void> {
    try {
      console.info('[WeatherHomePage] Refreshing current location...');
      this.currentError = ErrorHandler.createInfoMessage('æ­£åœ¨è·å–å½“å‰ä½ç½®...');
      
      // è·å–å½“å‰åæ ‡
      const coordinates = await LocationService.getInstance().getCurrentLocation();
      console.info(`[WeatherHomePage] Got coordinates: ${coordinates.latitude}, ${coordinates.longitude}`);
      
      // è·å–åŸå¸‚åç§°
      const cityName = await LocationService.getInstance().getCityNameFromCoordinates(coordinates);
      console.info(`[WeatherHomePage] Got city name: ${cityName}`);
      
      // æŸ¥æ‰¾æ˜¯å¦å·²æœ‰è‡ªåŠ¨å®šä½çš„åŸå¸‚
      const cities = this.controller.getCityStates();
      const autoCity = cities.find(state => state.city.source === CitySource.AUTO);
      
      if (autoCity) {
        // æ›´æ–°ç°æœ‰çš„è‡ªåŠ¨å®šä½åŸå¸‚
        const updatedCity = new City(
          autoCity.city.id,
          cityName,
          'Auto',
          coordinates,
          CitySource.AUTO,
          autoCity.city.videoTheme,
          autoCity.city.timeZoneOffsetMinutes
        );
        
        // æ›´æ–°åŸå¸‚åˆ—è¡¨
        const updatedCities = cities.map(state => 
          state.city.source === CitySource.AUTO ? updatedCity : state.city
        );
        
        await CityRepository.getInstance().updateCities(updatedCities);
        
        // åˆ·æ–°å¤©æ°”æ•°æ®
        await this.refresh(true);
        
        this.currentError = ErrorHandler.createInfoMessage(`ä½ç½®å·²æ›´æ–°ä¸º: ${cityName}`);
      } else {
        // æ·»åŠ æ–°çš„è‡ªåŠ¨å®šä½åŸå¸‚
        const newAutoCity = new City(
          `auto_${Math.round(coordinates.latitude * 1000)}_${Math.round(coordinates.longitude * 1000)}`,
          cityName,
          'Auto',
          coordinates,
          CitySource.AUTO,
          'sunny',
          0
        );
        
        await CityRepository.getInstance().addCity(newAutoCity);
        await this.refresh(true);
        
        this.currentError = ErrorHandler.createInfoMessage(`å·²æ·»åŠ å½“å‰ä½ç½®: ${cityName}`);
      }
      
      console.info(`[WeatherHomePage] Location refresh completed: ${cityName}`);
    } catch (error) {
      console.error('[WeatherHomePage] Location refresh failed:', error);
      this.currentError = ErrorHandler.handle(error as Error, 'è·å–å½“å‰ä½ç½®å¤±è´¥');
    }
  }

  private navigateToCityManagement(): void {
    try {
      console.info('[WeatherHomePage] Navigating to city management...');
      router.push({
        url: 'pages/management/CityManagementPage'
      });
      console.info('[WeatherHomePage] Navigation to city management successful');
    } catch (error) {
      console.error('[WeatherHomePage] Navigation failed:', error);
      this.currentError = ErrorHandler.handle(error instanceof Error ? error : new Error(String(error)), 'Failed to navigate');
    }
  }
}
