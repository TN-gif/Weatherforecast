import type common from '@ohos.app.ability.common';
import { WeatherDataRouter } from '../services/WeatherDataRouter';
import { WeatherCacheStorage } from '../storage/WeatherCacheStorage';
import { City, WeatherSnapshot } from '../models/WeatherModels';
import { MockWeatherRepository } from '../../mock/MockWeatherRepository';

export class WeatherRepository {
  private readonly router: WeatherDataRouter;
  private readonly cacheStorage: WeatherCacheStorage = WeatherCacheStorage.getInstance();
  private readonly mockRepository: MockWeatherRepository;

  constructor(router: WeatherDataRouter, mockRepository: MockWeatherRepository) {
    this.router = router;
    this.mockRepository = mockRepository;
  }

  async init(context: common.UIAbilityContext): Promise<void> {
    await this.cacheStorage.init(context);
  }

  async loadWeather(city: City, forceRefresh: boolean): Promise<WeatherSnapshot> {
    console.info(`[WeatherRepository] ========== å¼€å§‹åŠ è½½å¤©æ°”æ•°æ® ==========`);
    console.info(`[WeatherRepository] ğŸ™ï¸ åŸå¸‚: ${city.name} (${city.id})`);
    console.info(`[WeatherRepository] ğŸ”„ å¼ºåˆ¶åˆ·æ–°: ${forceRefresh}`);
    console.debug(`[WeatherRepository] ğŸ“ åæ ‡: ${JSON.stringify(city.coordinates)}`);
    
    // 1.æ£€æŸ¥ç¼“å­˜
    console.debug(`[WeatherRepository] ğŸ’¾ æ£€æŸ¥æœ¬åœ°ç¼“å­˜...`);
    const cached: WeatherSnapshot | null = await this.cacheStorage.loadSnapshot(city.id);
    
    if (cached) {
      const cacheAge = Date.now() - new Date(cached.lastUpdatedIso).getTime();
      const cacheAgeMinutes = Math.floor(cacheAge / (60 * 1000));
      const isValid = this.isCacheValid(cached);
      
      console.info(`[WeatherRepository] ğŸ“ ç¼“å­˜çŠ¶æ€: å¹´é¾„=${cacheAgeMinutes}åˆ†é’Ÿ, æœ‰æ•ˆ=${isValid}`);
      console.debug(`[WeatherRepository] ç¼“å­˜è¯¦æƒ…: Temp=${cached.current.temperatureC}Â°C, Source=${cached.dataSource}`);
      
      if (!forceRefresh && isValid) {
        console.info('[WeatherRepository] âœ… ä½¿ç”¨æœ‰æ•ˆç¼“å­˜æ•°æ®ï¼Œè·³è¿‡ç½‘ç»œè¯·æ±‚');
        console.info('[WeatherRepository] ========== åŠ è½½å®Œæˆ (ç¼“å­˜) ==========');
        return cached;
      } else {
        console.info(`[WeatherRepository] âš ï¸ ç¼“å­˜${forceRefresh ? 'è¢«å¼ºåˆ¶åˆ·æ–°å¿½ç•¥' : 'å·²è¿‡æœŸ'}ï¼Œå‡†å¤‡å‘èµ·ç½‘ç»œè¯·æ±‚`);
      }
    } else {
      console.info(`[WeatherRepository] âš ï¸ æœªæ‰¾åˆ°æœ¬åœ°ç¼“å­˜`);
    }
    
    try {
      // 2. ç½‘ç»œè¯·æ±‚
      console.info('[WeatherRepository] ğŸŒ å¼€å§‹ä»ç½‘ç»œè·å–æ–°æ•°æ®...');
      const fetchStartTime = Date.now();
      // ğŸ”§ ä¿®å¤ï¼šä¼ å…¥åŸå¸‚çš„æ—¶åŒºä¿¡æ¯
      const snapshot: WeatherSnapshot = await this.router.fetchWeather(city.id, city.coordinates, city.timeZoneOffsetMinutes);
      const fetchTime = Date.now() - fetchStartTime;
      
      console.info(`[WeatherRepository] âœ… ç½‘ç»œæ•°æ®è·å–æˆåŠŸï¼Œè€—æ—¶: ${fetchTime}ms`);
      console.info(`[WeatherRepository] ğŸ“Š æ–°æ•°æ®æ¦‚è§ˆ: Temp=${snapshot.current.temperatureC}Â°C, Alerts=${snapshot.alerts.length}, Rain=${snapshot.rainForecast.length}`);
      
      console.debug(`[WeatherRepository] ğŸ’¾ ä¿å­˜æ–°æ•°æ®åˆ°ç¼“å­˜...`);
      await this.cacheStorage.saveSnapshot(snapshot);
      
      console.info('[WeatherRepository] ========== åŠ è½½å®Œæˆ (ç½‘ç»œ) ==========');
      return snapshot;
    } catch (error) {
      const err = error as Error;
      console.error(`[WeatherRepository] âŒ ç½‘ç»œè·å–å¤±è´¥: ${err.name} - ${err.message}`);
      
      // 3. é™çº§æ–¹æ¡ˆ
      if (cached) {
        console.warn('[WeatherRepository] âš ï¸ ç½‘ç»œå¤±è´¥ï¼Œé™çº§ä½¿ç”¨è¿‡æœŸç¼“å­˜æ•°æ®');
        console.info(`[WeatherRepository] ========== åŠ è½½å®Œæˆ (é™çº§ç¼“å­˜) ==========`);
        return cached;
      }
      
      // æœ€åä½¿ç”¨Mockæ•°æ®
      console.warn('[WeatherRepository] âš ï¸ æ— ç¼“å­˜å¯ç”¨ï¼Œæœ€ç»ˆé™çº§ä½¿ç”¨Mockæ•°æ®');
      const mock: WeatherSnapshot = this.mockRepository.getSnapshot(city.id);
      console.info(`[WeatherRepository] ğŸ­ Mockæ•°æ®ç”Ÿæˆ: Temp=${mock.current.temperatureC}Â°C`);
      
      try {
        await this.cacheStorage.saveSnapshot(mock);
        console.debug(`[WeatherRepository] Mockæ•°æ®å·²ä¿å­˜åˆ°ç¼“å­˜`);
      } catch (saveError) {
        console.error(`[WeatherRepository] Mockæ•°æ®ä¿å­˜å¤±è´¥: ${(saveError as Error).message}`);
      }
      
      console.info('[WeatherRepository] ========== åŠ è½½å®Œæˆ (Mock) ==========');
      return mock;
    }
  }

  private isCacheValid(snapshot: WeatherSnapshot): boolean {
    const lastUpdate: number = new Date(snapshot.lastUpdatedIso).getTime();
    const diffMinutes: number = (Date.now() - lastUpdate) / (60 * 1000);
    const cacheMinutes: number = this.getCacheDuration(snapshot);
    
    const isValid = diffMinutes < cacheMinutes;
    if (!isValid) {
      console.debug(`[WeatherRepository] âŒ› ç¼“å­˜å¤±æ•ˆ: å·²å­˜${diffMinutes.toFixed(1)}åˆ†é’Ÿ > æœ‰æ•ˆæœŸ${cacheMinutes}åˆ†é’Ÿ`);
    }
    return isValid;
  }

  private getCacheDuration(snapshot: WeatherSnapshot): number {
    const iconCode: string = snapshot.current.condition.iconCode.toLowerCase();
    let duration = 30; // é»˜è®¤30åˆ†é’Ÿ
    let reason = 'é»˜è®¤ç­–ç•¥';

    if (iconCode.includes('thunder') || iconCode.includes('storm')) {
      duration = 10;
      reason = 'æ¶åŠ£å¤©æ°”(é›·æš´)';
    } else if (iconCode.includes('rain') || iconCode.includes('snow') || iconCode.includes('fog')) {
      duration = 20;
      reason = 'å˜åŒ–å¤©æ°”(é›¨é›ªé›¾)';
    } else if (snapshot.daily.length > 0) {
      const forecast = snapshot.daily[0];
      if (forecast.maxTempC - forecast.minTempC > 15) {
        duration = 25;
        reason = 'æ¸©å·®å¤§';
      }
    } else if (iconCode.includes('sunny') || iconCode.includes('clear')) {
      duration = 45;
      reason = 'ç¨³å®šå¤©æ°”(æ™´æœ—)';
    }
    
    // console.debug(`[WeatherRepository] â±ï¸ è®¡ç®—ç¼“å­˜æœ‰æ•ˆæœŸ: ${duration}åˆ†é’Ÿ (${reason})`);
    return duration;
  }
}
