import geoLocationManager from '@ohos.geoLocationManager';
import abilityAccessCtrl, { Permissions } from '@ohos.abilityAccessCtrl';
import type common from '@ohos.app.ability.common';
import bundleManager from '@ohos.bundle.bundleManager';
import { Coordinates, LocationError, LocationErrorCode } from '../models/WeatherModels';
import { AppConstants } from '../../common/constants/AppConstants';
import { BusinessError } from '@ohos.base';
import http from '@ohos.net.http';
import { DevicePerformanceDetector } from '../../common/utils/DevicePerformanceDetector';

interface IPLocationResponse {
  latitude: number;
  longitude: number;
  city?: string;
  country?: string;
}

interface GeocodingApiResult {
  id?: number;
  name: string;
  country: string;
  admin1?: string;
  latitude: number;
  longitude: number;
}

interface GeocodingApiResponse {
  results?: GeocodingApiResult[];
}


export class LocationService {
  private static instance: LocationService | null = null;
  private context: common.UIAbilityContext | null = null;

  private constructor() {}

  static getInstance(): LocationService {
    if (LocationService.instance === null) {
      LocationService.instance = new LocationService();
    }
    return LocationService.instance;
  }

  init(context: common.UIAbilityContext): void {
    this.context = context;
  }

  async getCurrentLocation(): Promise<Coordinates> {
    console.info('[LocationService] ========== å¼€å§‹è·å–å½“å‰ä½ç½® ==========');
    const startTime = Date.now();
    
    try {
      const coordinates = await this.getLocationWithFallback();
      const duration = Date.now() - startTime;
      console.info(`[LocationService] âœ… ä½ç½®è·å–æˆåŠŸï¼Œè€—æ—¶: ${duration}ms`);
      console.info(`[LocationService] ğŸ“ åæ ‡: ${coordinates.latitude}, ${coordinates.longitude}`);
      return coordinates;
    } catch (error) {
      const duration = Date.now() - startTime;
      console.error(`[LocationService] âŒ ä½ç½®è·å–å¤±è´¥ï¼Œè€—æ—¶: ${duration}ms`);
      const err = error instanceof Error ? error : new Error(String(error));
      throw err;
    }
  }

  async getLocationWithFallback(): Promise<Coordinates> {
    console.info('[LocationService] ğŸ¯ å¼€å§‹å¤šçº§å®šä½é™çº§ç­–ç•¥');
    
    // ç¬¬ä¸€çº§ï¼šç²¾ç¡®GPSå®šä½
    try {
      console.info('[LocationService] ğŸ“¡ å°è¯•GPSç²¾ç¡®å®šä½...');
      const preciseLocation = await this.getPreciseLocation();
      console.info('[LocationService] âœ… GPSå®šä½æˆåŠŸ');
      console.info(`[LocationService] ğŸ“ GPSåæ ‡: ${preciseLocation.latitude}, ${preciseLocation.longitude}`);
      return preciseLocation;
    } catch (error) {
      const locationError = error as LocationError;
      console.warn(`[LocationService] âŒ GPSå®šä½å¤±è´¥: é”™è¯¯ç =${locationError.code}, æ¶ˆæ¯=${locationError.message}`);
      
      // ç¬¬äºŒçº§ï¼šIPå®šä½
      try {
        console.info('[LocationService] ğŸŒ å°è¯•IPå®šä½...');
        const ipLocation = await this.fallbackToIPLocation();
        if (ipLocation) {
          console.info('[LocationService] âœ… IPå®šä½æˆåŠŸ');
          console.info(`[LocationService] ğŸ“ IPåæ ‡: ${ipLocation.latitude}, ${ipLocation.longitude}`);
          return ipLocation;
        } else {
          console.warn('[LocationService] âŒ IPå®šä½è¿”å›ç©ºç»“æœ');
        }
      } catch (ipError) {
        console.error('[LocationService] âŒ IPå®šä½å¼‚å¸¸:', ipError);
      }
      
      // ç¬¬ä¸‰çº§ï¼šé»˜è®¤ä½ç½®
      console.info('[LocationService] ğŸ  ä½¿ç”¨é»˜è®¤ä½ç½® (ä¸Šæµ·)');
      const defaultLocation = this.getDefaultLocation();
      console.info(`[LocationService] ğŸ“ é»˜è®¤åæ ‡: ${defaultLocation.latitude}, ${defaultLocation.longitude}`);
      return defaultLocation;
    }
  }

  private async getPreciseLocation(): Promise<Coordinates> {
    if (!this.context) {
      throw new LocationError(LocationErrorCode.CONTEXT_UNAVAILABLE, 'Context not available');
    }

    // âœ… Simulator Check: Skip GPS on simulator to avoid timeout
    const performanceDetector = DevicePerformanceDetector.getInstance();
    const capability = await performanceDetector.detect();
    if (capability.isSimulator) {
      console.warn('[LocationService] Simulator detected, skipping GPS to avoid timeout');
      throw new LocationError(LocationErrorCode.LOCATION_TIMEOUT, 'Simulator: GPS skipped');
    }
    
    try {
      await this.ensureLocationPermission();
      await this.ensureLocationEnabled();
      
      const position: geoLocationManager.Location = await geoLocationManager.getCurrentLocation({
        priority: geoLocationManager.LocationRequestPriority.FIRST_FIX,
        scenario: geoLocationManager.LocationRequestScenario.UNSET,
        timeoutMs: 15000
      });
      
      const coordinates: Coordinates = {
        latitude: position.latitude,
        longitude: position.longitude
      };
      return coordinates;
    } catch (error) {
      const businessError = error as BusinessError;
      const errorCode = this.mapBusinessErrorToLocationError(businessError.code);
      const errorMessage = businessError.message || 'Location service error';
      throw new LocationError(errorCode, errorMessage);
    }
  }

  private mapBusinessErrorToLocationError(code: number): LocationErrorCode {
    switch (code) {
      case 201:
        return LocationErrorCode.PERMISSION_DENIED;
      case 301:
        return LocationErrorCode.LOCATION_SWITCH_OFF;
      case 800:
        return LocationErrorCode.LOCATION_TIMEOUT;
      default:
        return LocationErrorCode.UNKNOWN_ERROR;
    }
  }

  async requestLocationPermission(): Promise<boolean> {
    if (!this.context) {
      console.error('[LocationService] Context not available for permission request');
      return false;
    }
    
    const atManager = abilityAccessCtrl.createAtManager();
    try {
      console.info('[LocationService] Requesting location permissions...');
      const grantStatus = await atManager.requestPermissionsFromUser(
        this.context,
        [
          AppConstants.LOCATION_PERMISSION as Permissions,
          AppConstants.APPROX_LOCATION_PERMISSION as Permissions
        ]
      );
      
      const allGranted = grantStatus.authResults.every(grant => grant === abilityAccessCtrl.GrantStatus.PERMISSION_GRANTED);
      console.info(`[LocationService] Permission request result: ${allGranted ? 'granted' : 'denied'}`);
      return allGranted;
    } catch (err) {
      console.error(`[LocationService] Permission request failed: ${JSON.stringify(err)}`);
      return false;
    }
  }

  private async ensureLocationPermission(): Promise<void> {
    if (!this.context) {
      throw new LocationError(LocationErrorCode.CONTEXT_UNAVAILABLE, 'Context not available');
    }
    
    const atManager = abilityAccessCtrl.createAtManager();
    const bundleInfo = await bundleManager.getBundleInfoForSelf(bundleManager.BundleFlag.GET_BUNDLE_INFO_WITH_APPLICATION);
    const tokenId = bundleInfo.appInfo.accessTokenId;
    
    const permissions: Permissions[] = [
      AppConstants.LOCATION_PERMISSION as Permissions,
      AppConstants.APPROX_LOCATION_PERMISSION as Permissions
    ];
    
    for (const permission of permissions) {
      const grantStatus = await atManager.checkAccessToken(tokenId, permission);
      if (grantStatus === abilityAccessCtrl.GrantStatus.PERMISSION_DENIED) {
        const hasPermission = await this.requestLocationPermission();
        if (!hasPermission) {
          throw new LocationError(LocationErrorCode.PERMISSION_DENIED, 'Location permission denied');
        }
      }
    }
  }

  private async ensureLocationEnabled(): Promise<void> {
    const enabled: boolean = await geoLocationManager.isLocationEnabled();
    if (!enabled) {
      throw new LocationError(LocationErrorCode.LOCATION_SWITCH_OFF, 'Location disabled');
    }
  }

  private async handleLocationError(error: BusinessError): Promise<Coordinates> {
    const code: number = error.code ?? 0;
    console.warn(`[LocationService] location failed, code=${code}, message=${error.message}`);
    if (code === LocationErrorCode.PERMISSION_DENIED) {
      throw new Error('éœ€è¦å¼€å¯å®šä½æƒé™æ‰èƒ½è‡ªåŠ¨å®šä½');
    }
    if (code === LocationErrorCode.LOCATION_TIMEOUT) {
      const ipLocation: Coordinates | null = await this.fallbackToIPLocation();
      if (ipLocation !== null) {
        return ipLocation;
      }
    }
    return this.getDefaultLocation();
  }

  private async fallbackToIPLocation(): Promise<Coordinates | null> {
    const request: http.HttpRequest = http.createHttp();
    try {
      const ipRequestConfig: http.HttpRequestOptions = {
        method: http.RequestMethod.GET,
        expectDataType: http.HttpDataType.STRING,
        connectTimeout: 5000,
        readTimeout: 5000
      };
      const response: http.HttpResponse = await request.request('https://ipapi.co/json/', ipRequestConfig);
      const payload = JSON.parse(response.result as string) as IPLocationResponse;
      if (payload.latitude && payload.longitude) {
        const ipCoordinates: Coordinates = {
          latitude: payload.latitude,
          longitude: payload.longitude
        };
        return ipCoordinates;
      }
      return null;
    } catch (err) {
      console.warn('[LocationService] IP location failed');
      return null;
    } finally {
      request.destroy();
    }
  }

  /**
   * åå‘åœ°ç†ç¼–ç ï¼šæ ¹æ®åæ ‡è·å–åŸå¸‚åç§°
   */
  async getCityNameFromCoordinates(coordinates: Coordinates): Promise<string> {
    console.info('[LocationService] ========== å¼€å§‹åå‘åœ°ç†ç¼–ç  ==========');
    console.info(`[LocationService] ğŸ—ºï¸ è¾“å…¥åæ ‡: ${coordinates.latitude}, ${coordinates.longitude}`);
    
    const request: http.HttpRequest = http.createHttp();
    const startTime = Date.now();
    
    try {
      const geocodingUrl = `https://geocoding-api.open-meteo.com/v1/search?latitude=${coordinates.latitude}&longitude=${coordinates.longitude}&count=1&language=zh&format=json`;
      console.info(`[LocationService] ğŸŒ è¯·æ±‚URL: ${geocodingUrl}`);
      
      const geocodingConfig: http.HttpRequestOptions = {
        method: http.RequestMethod.GET,
        expectDataType: http.HttpDataType.STRING,
        connectTimeout: 8000,
        readTimeout: 8000
      };
      
      console.info('[LocationService] ğŸ“¡ å‘é€åœ°ç†ç¼–ç APIè¯·æ±‚...');
      const response: http.HttpResponse = await request.request(geocodingUrl, geocodingConfig);
      const duration = Date.now() - startTime;
      
      console.info(`[LocationService] ğŸ“¡ APIå“åº”: çŠ¶æ€ç =${response.responseCode}, è€—æ—¶=${duration}ms`);
      
      if (response.responseCode !== 200) {
        console.warn(`[LocationService] âŒ åœ°ç†ç¼–ç APIå¤±è´¥: ${response.responseCode}`);
        console.info('[LocationService] ğŸ”„ åˆ‡æ¢åˆ°åæ ‡æ¨æµ‹æ¨¡å¼');
        return this.getFallbackCityName(coordinates);
      }
      
      const responseText = response.result as string;
      console.info(`[LocationService] ğŸ“„ APIå“åº”å†…å®¹: ${responseText.substring(0, 200)}...`);
      
      const data = JSON.parse(responseText) as GeocodingApiResponse;
      
      if (data.results && data.results.length > 0) {
        const result = data.results[0];
        console.info(`[LocationService] ğŸ™ï¸ è§£æç»“æœ: name=${result.name}, admin1=${result.admin1}, country=${result.country}`);
        
        let cityName = result.name;
        
        // å¦‚æœæœ‰çœä»½ä¿¡æ¯ï¼Œç»„åˆæ˜¾ç¤º
        if (result.admin1 && result.admin1 !== result.name) {
          cityName = `${result.name}, ${result.admin1}`;
          console.info(`[LocationService] ğŸ·ï¸ ç»„åˆåŸå¸‚å: ${cityName}`);
        }
        
        console.info(`[LocationService] âœ… åœ°ç†ç¼–ç æˆåŠŸ: ${cityName}`);
        return cityName;
      } else {
        console.warn('[LocationService] âŒ APIè¿”å›ç©ºç»“æœ');
        console.info('[LocationService] ğŸ”„ åˆ‡æ¢åˆ°åæ ‡æ¨æµ‹æ¨¡å¼');
        return this.getFallbackCityName(coordinates);
      }
      
    } catch (error) {
      const duration = Date.now() - startTime;
      console.error(`[LocationService] âŒ åœ°ç†ç¼–ç å¼‚å¸¸ï¼Œè€—æ—¶=${duration}ms:`, error);
      console.info('[LocationService] ğŸ”„ åˆ‡æ¢åˆ°åæ ‡æ¨æµ‹æ¨¡å¼');
      return this.getFallbackCityName(coordinates);
    } finally {
      request.destroy();
    }
  }

  /**
   * è·å–å¤‡ç”¨åŸå¸‚åç§°ï¼ˆåŸºäºåæ ‡èŒƒå›´æ¨æµ‹ï¼‰
   */
  private getFallbackCityName(coordinates: Coordinates): string {
    console.info('[LocationService] ğŸ§­ å¼€å§‹åæ ‡èŒƒå›´æ¨æµ‹');
    const lat = coordinates.latitude;
    const lng = coordinates.longitude;
    console.info(`[LocationService] ğŸ“ åˆ†æåæ ‡: çº¬åº¦=${lat}, ç»åº¦=${lng}`);
    
    let cityName: string;
    
    // ä¸­å›½ä¸»è¦åŸå¸‚åæ ‡èŒƒå›´åˆ¤æ–­
    if (lat >= 39.8 && lat <= 40.2 && lng >= 116.2 && lng <= 116.6) {
      cityName = 'åŒ—äº¬';
      console.info('[LocationService] ğŸ›ï¸ åæ ‡åŒ¹é…: åŒ—äº¬å¸‚èŒƒå›´');
    } else if (lat >= 31.1 && lat <= 31.4 && lng >= 121.3 && lng <= 121.7) {
      cityName = 'ä¸Šæµ·';
      console.info('[LocationService] ğŸ™ï¸ åæ ‡åŒ¹é…: ä¸Šæµ·å¸‚èŒƒå›´');
    } else if (lat >= 22.4 && lat <= 22.8 && lng >= 113.8 && lng <= 114.6) {
      cityName = 'æ·±åœ³';
      console.info('[LocationService] ğŸŒ† åæ ‡åŒ¹é…: æ·±åœ³å¸‚èŒƒå›´');
    } else if (lat >= 23.0 && lat <= 23.4 && lng >= 113.1 && lng <= 113.5) {
      cityName = 'å¹¿å·';
      console.info('[LocationService] ğŸ¢ åæ ‡åŒ¹é…: å¹¿å·å¸‚èŒƒå›´');
    } else if (lat >= 30.4 && lat <= 30.8 && lng >= 104.0 && lng <= 104.2) {
      cityName = 'æˆéƒ½';
      console.info('[LocationService] ğŸ¼ åæ ‡åŒ¹é…: æˆéƒ½å¸‚èŒƒå›´');
    } else if (lat >= 29.4 && lat <= 29.8 && lng >= 106.3 && lng <= 106.8) {
      cityName = 'é‡åº†';
      console.info('[LocationService] ğŸŒ‰ åæ ‡åŒ¹é…: é‡åº†å¸‚èŒƒå›´');
    } else if (lat >= 36.0 && lat <= 36.4 && lng >= 120.2 && lng <= 120.5) {
      cityName = 'é’å²›';
      console.info('[LocationService] ğŸŒŠ åæ ‡åŒ¹é…: é’å²›å¸‚èŒƒå›´');
    } else if (lat >= 32.0 && lat <= 32.2 && lng >= 118.6 && lng <= 119.0) {
      cityName = 'å—äº¬';
      console.info('[LocationService] ğŸ® åæ ‡åŒ¹é…: å—äº¬å¸‚èŒƒå›´');
    } else if (lat >= 30.2 && lat <= 30.4 && lng >= 120.0 && lng <= 120.3) {
      cityName = 'æ­å·';
      console.info('[LocationService] ğŸï¸ åæ ‡åŒ¹é…: æ­å·å¸‚èŒƒå›´');
    } else if (lat >= 38.8 && lat <= 39.2 && lng >= 117.1 && lng <= 117.4) {
      cityName = 'å¤©æ´¥';
      console.info('[LocationService] ğŸš¢ åæ ‡åŒ¹é…: å¤©æ´¥å¸‚èŒƒå›´');
    } else {
      // æ ¹æ®å¤§è‡´åŒºåŸŸåˆ¤æ–­
      if (lat >= 18 && lat <= 54 && lng >= 73 && lng <= 135) {
        cityName = 'ä¸­å›½å¢ƒå†…';
        console.info('[LocationService] ğŸ‡¨ğŸ‡³ åæ ‡åœ¨ä¸­å›½å¢ƒå†…ï¼Œä½†æœªåŒ¹é…åˆ°å…·ä½“åŸå¸‚');
      } else {
        cityName = `ä½ç½® ${lat.toFixed(2)}, ${lng.toFixed(2)}`;
        console.info('[LocationService] ğŸŒ åæ ‡åœ¨ä¸­å›½å¢ƒå¤–æˆ–æ— æ³•è¯†åˆ«');
      }
    }
    
    console.info(`[LocationService] âœ… åæ ‡æ¨æµ‹ç»“æœ: ${cityName}`);
    return cityName;
  }

  private getDefaultLocation(): Coordinates {
    const defaultCoordinates: Coordinates = {
      latitude: 31.2304,
      longitude: 121.4737
    };
    return defaultCoordinates;
  }
}
