import geoLocationManager from '@ohos.geoLocationManager';
import abilityAccessCtrl, { Permissions } from '@ohos.abilityAccessCtrl';
import type common from '@ohos.app.ability.common';
import bundleManager from '@ohos.bundle.bundleManager';
import { Coordinates, LocationError, LocationErrorCode } from '../models/WeatherModels';
import { AppConstants } from '../../common/constants/AppConstants';
import { BusinessError } from '@ohos.base';
import http from '@ohos.net.http';
import { DevicePerformanceDetector } from '../../common/utils/DevicePerformanceDetector';
import { GeoServiceRouter } from './GeoServiceRouter';

interface IPLocationResponse {
  latitude: number;
  longitude: number;
  city?: string;
  country?: string;
}

export class LocationService {
  private static instance: LocationService | null = null;
  private context: common.UIAbilityContext | null = null;
  private readonly geoRouter: GeoServiceRouter = new GeoServiceRouter();

  private constructor() {}

  static getInstance(): LocationService {
    if (LocationService.instance === null) {
      LocationService.instance = new LocationService();
    }
    return LocationService.instance;
  }

  init(context: common.UIAbilityContext): void {
    this.context = context;
  }

  async getCurrentLocation(): Promise<Coordinates> {
    console.info('[LocationService] ========== å¼€å§‹è·å–å½“å‰ä½ç½® ==========');
    const startTime = Date.now();
    
    try {
      const coordinates = await this.getLocationWithFallback();
      const duration = Date.now() - startTime;
      console.info(`[LocationService] âœ… ä½ç½®è·å–æˆåŠŸï¼Œè€—æ—¶: ${duration}ms`);
      console.info(`[LocationService] ğŸ“ åæ ‡: ${coordinates.latitude}, ${coordinates.longitude}`);
      return coordinates;
    } catch (error) {
      const duration = Date.now() - startTime;
      console.error(`[LocationService] âŒ ä½ç½®è·å–å¤±è´¥ï¼Œè€—æ—¶: ${duration}ms`);
      const err = error instanceof Error ? error : new Error(String(error));
      throw err;
    }
  }

  async getLocationWithFallback(): Promise<Coordinates> {
    console.info('[LocationService] ğŸ¯ å¼€å§‹å¤šçº§å®šä½é™çº§ç­–ç•¥');
    
    // ç¬¬ä¸€çº§ï¼šç²¾ç¡®GPSå®šä½
    try {
      console.info('[LocationService] ğŸ“¡ å°è¯•GPSç²¾ç¡®å®šä½...');
      const preciseLocation = await this.getPreciseLocation();
      console.info('[LocationService] âœ… GPSå®šä½æˆåŠŸ');
      console.info(`[LocationService] ğŸ“ GPSåæ ‡: ${preciseLocation.latitude}, ${preciseLocation.longitude}`);
      return preciseLocation;
    } catch (error) {
      const locationError = error as LocationError;
      console.warn(`[LocationService] âŒ GPSå®šä½å¤±è´¥: é”™è¯¯ç =${locationError.code}, æ¶ˆæ¯=${locationError.message}`);
      
      // ç¬¬äºŒçº§ï¼šIPå®šä½
      try {
        console.info('[LocationService] ğŸŒ å°è¯•IPå®šä½...');
        const ipLocation = await this.fallbackToIPLocation();
        if (ipLocation) {
          console.info('[LocationService] âœ… IPå®šä½æˆåŠŸ');
          console.info(`[LocationService] ğŸ“ IPåæ ‡: ${ipLocation.latitude}, ${ipLocation.longitude}`);
          return ipLocation;
        } else {
          console.warn('[LocationService] âŒ IPå®šä½è¿”å›ç©ºç»“æœ');
        }
      } catch (ipError) {
        console.error('[LocationService] âŒ IPå®šä½å¼‚å¸¸:', ipError);
      }
      
      // ç¬¬ä¸‰çº§ï¼šé»˜è®¤ä½ç½®
      console.info('[LocationService] ğŸ  ä½¿ç”¨é»˜è®¤ä½ç½® (ä¸Šæµ·)');
      const defaultLocation = this.getDefaultLocation();
      console.info(`[LocationService] ğŸ“ é»˜è®¤åæ ‡: ${defaultLocation.latitude}, ${defaultLocation.longitude}`);
      return defaultLocation;
    }
  }

  private async getPreciseLocation(): Promise<Coordinates> {
    console.info('[LocationService] ğŸ¯ å¼€å§‹GPSç²¾ç¡®å®šä½æµç¨‹');
    
    if (!this.context) {
      console.error('[LocationService] âŒ Contextä¸å¯ç”¨');
      throw new LocationError(LocationErrorCode.CONTEXT_UNAVAILABLE, 'Context not available');
    }
    console.debug('[LocationService] âœ… Contextæœ‰æ•ˆ');

    // ç§»é™¤æ¨¡æ‹Ÿå™¨æ£€æŸ¥ï¼Œå…è®¸åœ¨æ¨¡æ‹Ÿå™¨ä¸­ä½¿ç”¨GPS
    console.debug('[LocationService] âœ… ç»§ç»­GPSå®šä½æµç¨‹');
    
    try {
      console.debug('[LocationService] ğŸ” æ£€æŸ¥å®šä½æƒé™...');
      await this.ensureLocationPermission();
      console.debug('[LocationService] âœ… å®šä½æƒé™å·²æˆäºˆ');
      
      console.debug('[LocationService] ğŸ”Œ æ£€æŸ¥å®šä½å¼€å…³...');
      await this.ensureLocationEnabled();
      console.debug('[LocationService] âœ… å®šä½å¼€å…³å·²å¼€å¯');
      
      console.info('[LocationService] ğŸ“¡ å¼€å§‹è°ƒç”¨ç³»ç»ŸGPSæ¥å£...');
      console.debug('[LocationService] GPSé…ç½®: priority=FIRST_FIX, timeout=15000ms');
      const gpsStartTime = Date.now();
      
      const position: geoLocationManager.Location = await geoLocationManager.getCurrentLocation({
        priority: geoLocationManager.LocationRequestPriority.FIRST_FIX,
        scenario: geoLocationManager.LocationRequestScenario.UNSET,
        timeoutMs: 15000
      });
      
      const gpsDuration = Date.now() - gpsStartTime;
      console.info(`[LocationService] âœ… GPSå®šä½æˆåŠŸï¼Œè€—æ—¶: ${gpsDuration}ms`);
      
      const coordinates: Coordinates = {
        latitude: position.latitude,
        longitude: position.longitude
      };
      console.debug(`[LocationService] ğŸ“ åŸå§‹GPSåæ ‡: lat=${coordinates.latitude}, lon=${coordinates.longitude}`);
      console.debug(`[LocationService] GPSç²¾åº¦: ${position.accuracy || 'N/A'}ç±³`);
      
      return coordinates;
    } catch (error) {
      const businessError = error as BusinessError;
      const errorCode = this.mapBusinessErrorToLocationError(businessError.code);
      const errorMessage = businessError.message || 'Location service error';
      console.error(`[LocationService] âŒ GPSå®šä½å¤±è´¥: é”™è¯¯ç =${businessError.code}, æ¶ˆæ¯=${errorMessage}`);
      throw new LocationError(errorCode, errorMessage);
    }
  }

  private mapBusinessErrorToLocationError(code: number): LocationErrorCode {
    switch (code) {
      case 201:
        return LocationErrorCode.PERMISSION_DENIED;
      case 301:
        return LocationErrorCode.LOCATION_SWITCH_OFF;
      case 800:
        return LocationErrorCode.LOCATION_TIMEOUT;
      default:
        return LocationErrorCode.UNKNOWN_ERROR;
    }
  }

  async requestLocationPermission(): Promise<boolean> {
    if (!this.context) {
      console.error('[LocationService] Context not available for permission request');
      return false;
    }
    
    const atManager = abilityAccessCtrl.createAtManager();
    try {
      console.info('[LocationService] Requesting location permissions...');
      const grantStatus = await atManager.requestPermissionsFromUser(
        this.context,
        [
          AppConstants.LOCATION_PERMISSION as Permissions,
          AppConstants.APPROX_LOCATION_PERMISSION as Permissions
        ]
      );
      
      const allGranted = grantStatus.authResults.every(grant => grant === abilityAccessCtrl.GrantStatus.PERMISSION_GRANTED);
      console.info(`[LocationService] Permission request result: ${allGranted ? 'granted' : 'denied'}`);
      return allGranted;
    } catch (err) {
      console.error(`[LocationService] Permission request failed: ${JSON.stringify(err)}`);
      return false;
    }
  }

  private async ensureLocationPermission(): Promise<void> {
    console.debug('[LocationService] ğŸ” å¼€å§‹æƒé™éªŒè¯æµç¨‹');
    
    if (!this.context) {
      console.error('[LocationService] âŒ Contextä¸å¯ç”¨ï¼Œæ— æ³•æ£€æŸ¥æƒé™');
      throw new LocationError(LocationErrorCode.CONTEXT_UNAVAILABLE, 'Context not available');
    }
    
    const atManager = abilityAccessCtrl.createAtManager();
    const bundleInfo = await bundleManager.getBundleInfoForSelf(bundleManager.BundleFlag.GET_BUNDLE_INFO_WITH_APPLICATION);
    const tokenId = bundleInfo.appInfo.accessTokenId;
    console.debug(`[LocationService] åº”ç”¨Token ID: ${tokenId}`);
    
    const permissions: Permissions[] = [
      AppConstants.LOCATION_PERMISSION as Permissions,
      AppConstants.APPROX_LOCATION_PERMISSION as Permissions
    ];
    
    console.debug(`[LocationService] éœ€è¦æ£€æŸ¥ ${permissions.length} ä¸ªæƒé™`);
    
    for (let i = 0; i < permissions.length; i++) {
      const permission = permissions[i];
      console.debug(`[LocationService] æ£€æŸ¥æƒé™ ${i + 1}/${permissions.length}: ${permission}`);
      
      const grantStatus = await atManager.checkAccessToken(tokenId, permission);
      
      if (grantStatus === abilityAccessCtrl.GrantStatus.PERMISSION_GRANTED) {
        console.debug(`[LocationService] âœ… æƒé™å·²æˆäºˆ: ${permission}`);
      } else if (grantStatus === abilityAccessCtrl.GrantStatus.PERMISSION_DENIED) {
        console.warn(`[LocationService] âš ï¸ æƒé™æœªæˆäºˆ: ${permission}ï¼Œå°è¯•è¯·æ±‚...`);
        const hasPermission = await this.requestLocationPermission();
        if (!hasPermission) {
          console.error(`[LocationService] âŒ æƒé™è¯·æ±‚è¢«æ‹’ç»: ${permission}`);
          throw new LocationError(LocationErrorCode.PERMISSION_DENIED, 'Location permission denied');
        }
        console.info(`[LocationService] âœ… æƒé™è¯·æ±‚æˆåŠŸ: ${permission}`);
      }
    }
    
    console.debug('[LocationService] âœ… æ‰€æœ‰å®šä½æƒé™éªŒè¯é€šè¿‡');
  }

  private async ensureLocationEnabled(): Promise<void> {
    console.debug('[LocationService] ğŸ”Œ æ£€æŸ¥ç³»ç»Ÿå®šä½å¼€å…³çŠ¶æ€...');
    const enabled: boolean = await geoLocationManager.isLocationEnabled();
    
    if (!enabled) {
      console.error('[LocationService] âŒ ç³»ç»Ÿå®šä½å¼€å…³æœªå¼€å¯');
      throw new LocationError(LocationErrorCode.LOCATION_SWITCH_OFF, 'Location disabled');
    }
    
    console.debug('[LocationService] âœ… ç³»ç»Ÿå®šä½å¼€å…³å·²å¼€å¯');
  }

  private async handleLocationError(error: BusinessError): Promise<Coordinates> {
    const code: number = error.code ?? 0;
    console.warn(`[LocationService] location failed, code=${code}, message=${error.message}`);
    if (code === LocationErrorCode.PERMISSION_DENIED) {
      throw new Error('éœ€è¦å¼€å¯å®šä½æƒé™æ‰èƒ½è‡ªåŠ¨å®šä½');
    }
    if (code === LocationErrorCode.LOCATION_TIMEOUT) {
      const ipLocation: Coordinates | null = await this.fallbackToIPLocation();
      if (ipLocation !== null) {
        return ipLocation;
      }
    }
    return this.getDefaultLocation();
  }

  private async fallbackToIPLocation(): Promise<Coordinates | null> {
    console.info('[LocationService] ğŸŒ å¼€å§‹IPå®šä½é™çº§æµç¨‹');
    const request: http.HttpRequest = http.createHttp();
    
    try {
      const ipApiUrl = 'https://ipapi.co/json/';
      console.debug(`[LocationService] IPå®šä½API: ${ipApiUrl}`);
      console.debug('[LocationService] è¯·æ±‚è¶…æ—¶é…ç½®: connect=5s, read=5s');
      
      const startTime = Date.now();
      
      const ipRequestConfig: http.HttpRequestOptions = {
        method: http.RequestMethod.GET,
        expectDataType: http.HttpDataType.STRING,
        connectTimeout: 5000,
        readTimeout: 5000
      };
      
      console.debug('[LocationService] å‘é€IPå®šä½è¯·æ±‚...');
      const response: http.HttpResponse = await request.request(ipApiUrl, ipRequestConfig);
      const duration = Date.now() - startTime;
      
      console.debug(`[LocationService] IPå®šä½å“åº”: status=${response.responseCode}, è€—æ—¶=${duration}ms`);
      
      if (response.responseCode !== 200) {
        console.warn(`[LocationService] âŒ IPå®šä½APIè¿”å›é”™è¯¯çŠ¶æ€ç : ${response.responseCode}`);
        return null;
      }
      
      const payload = JSON.parse(response.result as string) as IPLocationResponse;
      console.debug(`[LocationService] IPå®šä½å“åº”æ•°æ®: ${JSON.stringify(payload)}`);
      
      if (payload.latitude && payload.longitude) {
        const ipCoordinates: Coordinates = {
          latitude: payload.latitude,
          longitude: payload.longitude
        };
        console.info(`[LocationService] âœ… IPå®šä½æˆåŠŸ: lat=${ipCoordinates.latitude}, lon=${ipCoordinates.longitude}`);
        if (payload.city) {
          console.debug(`[LocationService] IPå®šä½åŸå¸‚: ${payload.city}`);
        }
        return ipCoordinates;
      } else {
        console.warn('[LocationService] âŒ IPå®šä½å“åº”ç¼ºå°‘åæ ‡æ•°æ®');
        return null;
      }
    } catch (err) {
      console.error('[LocationService] âŒ IPå®šä½å¼‚å¸¸:', err);
      return null;
    } finally {
      request.destroy();
      console.debug('[LocationService] HTTPè¯·æ±‚å·²æ¸…ç†');
    }
  }

  /**
   * åå‘åœ°ç†ç¼–ç ï¼šæ ¹æ®åæ ‡è·å–åŸå¸‚åç§°ï¼ˆä½¿ç”¨æ™ºèƒ½è·¯ç”±ï¼‰
   */
  async getCityNameFromCoordinates(coordinates: Coordinates): Promise<string> {
    console.info('[LocationService] ========== å¼€å§‹åå‘åœ°ç†ç¼–ç ï¼ˆæ™ºèƒ½è·¯ç”±ï¼‰ ==========');
    console.info(`[LocationService] ğŸ—ºï¸ è¾“å…¥åæ ‡: ${coordinates.latitude}, ${coordinates.longitude}`);
    
    const startTime = Date.now();
    
    try {
      const cityName = await this.geoRouter.reverseGeocode(coordinates);
      const duration = Date.now() - startTime;
      
      if (cityName) {
        console.info(`[LocationService] âœ… æ™ºèƒ½è·¯ç”±æˆåŠŸï¼Œè€—æ—¶: ${duration}ms`);
        console.info(`[LocationService] ğŸ™ï¸ åŸå¸‚åç§°: ${cityName}`);
        return cityName;
      } else {
        console.warn(`[LocationService] âŒ æ™ºèƒ½è·¯ç”±è¿”å›ç©ºï¼Œè€—æ—¶: ${duration}ms`);
        console.info('[LocationService] ğŸ”„ åˆ‡æ¢åˆ°åæ ‡æ¨æµ‹æ¨¡å¼');
        return this.getFallbackCityName(coordinates);
      }
      
    } catch (error) {
      const duration = Date.now() - startTime;
      console.error(`[LocationService] âŒ æ™ºèƒ½è·¯ç”±å¼‚å¸¸ï¼Œè€—æ—¶: ${duration}ms:`, error);
      console.info('[LocationService] ğŸ”„ åˆ‡æ¢åˆ°åæ ‡æ¨æµ‹æ¨¡å¼');
      return this.getFallbackCityName(coordinates);
    }
  }

  /**
   * è·å–å¤‡ç”¨åŸå¸‚åç§°ï¼ˆåŸºäºåæ ‡èŒƒå›´æ¨æµ‹ï¼‰
   */
  private getFallbackCityName(coordinates: Coordinates): string {
    console.info('[LocationService] ğŸ§­ å¼€å§‹åæ ‡èŒƒå›´æ¨æµ‹');
    const lat = coordinates.latitude;
    const lng = coordinates.longitude;
    console.info(`[LocationService] ğŸ“ åˆ†æåæ ‡: çº¬åº¦=${lat}, ç»åº¦=${lng}`);
    
    let cityName: string;
    
    // ä¸­å›½ä¸»è¦åŸå¸‚åæ ‡èŒƒå›´åˆ¤æ–­
    if (lat >= 39.8 && lat <= 40.2 && lng >= 116.2 && lng <= 116.6) {
      cityName = 'åŒ—äº¬';
      console.info('[LocationService] ğŸ›ï¸ åæ ‡åŒ¹é…: åŒ—äº¬å¸‚èŒƒå›´');
    } else if (lat >= 31.1 && lat <= 31.4 && lng >= 121.3 && lng <= 121.7) {
      cityName = 'ä¸Šæµ·';
      console.info('[LocationService] ğŸ™ï¸ åæ ‡åŒ¹é…: ä¸Šæµ·å¸‚èŒƒå›´');
    } else if (lat >= 22.4 && lat <= 22.8 && lng >= 113.8 && lng <= 114.6) {
      cityName = 'æ·±åœ³';
      console.info('[LocationService] ğŸŒ† åæ ‡åŒ¹é…: æ·±åœ³å¸‚èŒƒå›´');
    } else if (lat >= 23.0 && lat <= 23.4 && lng >= 113.1 && lng <= 113.5) {
      cityName = 'å¹¿å·';
      console.info('[LocationService] ğŸ¢ åæ ‡åŒ¹é…: å¹¿å·å¸‚èŒƒå›´');
    } else if (lat >= 30.4 && lat <= 30.8 && lng >= 104.0 && lng <= 104.2) {
      cityName = 'æˆéƒ½';
      console.info('[LocationService] ğŸ¼ åæ ‡åŒ¹é…: æˆéƒ½å¸‚èŒƒå›´');
    } else if (lat >= 29.4 && lat <= 29.8 && lng >= 106.3 && lng <= 106.8) {
      cityName = 'é‡åº†';
      console.info('[LocationService] ğŸŒ‰ åæ ‡åŒ¹é…: é‡åº†å¸‚èŒƒå›´');
    } else if (lat >= 36.0 && lat <= 36.4 && lng >= 120.2 && lng <= 120.5) {
      cityName = 'é’å²›';
      console.info('[LocationService] ğŸŒŠ åæ ‡åŒ¹é…: é’å²›å¸‚èŒƒå›´');
    } else if (lat >= 32.0 && lat <= 32.2 && lng >= 118.6 && lng <= 119.0) {
      cityName = 'å—äº¬';
      console.info('[LocationService] ğŸ® åæ ‡åŒ¹é…: å—äº¬å¸‚èŒƒå›´');
    } else if (lat >= 30.2 && lat <= 30.4 && lng >= 120.0 && lng <= 120.3) {
      cityName = 'æ­å·';
      console.info('[LocationService] ğŸï¸ åæ ‡åŒ¹é…: æ­å·å¸‚èŒƒå›´');
    } else if (lat >= 38.8 && lat <= 39.2 && lng >= 117.1 && lng <= 117.4) {
      cityName = 'å¤©æ´¥';
      console.info('[LocationService] ğŸš¢ åæ ‡åŒ¹é…: å¤©æ´¥å¸‚èŒƒå›´');
    } else {
      // æ ¹æ®å¤§è‡´åŒºåŸŸåˆ¤æ–­
      if (lat >= 18 && lat <= 54 && lng >= 73 && lng <= 135) {
        cityName = 'ä¸­å›½å¢ƒå†…';
        console.info('[LocationService] ğŸ‡¨ğŸ‡³ åæ ‡åœ¨ä¸­å›½å¢ƒå†…ï¼Œä½†æœªåŒ¹é…åˆ°å…·ä½“åŸå¸‚');
      } else {
        cityName = `ä½ç½® ${lat.toFixed(2)}, ${lng.toFixed(2)}`;
        console.info('[LocationService] ğŸŒ åæ ‡åœ¨ä¸­å›½å¢ƒå¤–æˆ–æ— æ³•è¯†åˆ«');
      }
    }
    
    console.info(`[LocationService] âœ… åæ ‡æ¨æµ‹ç»“æœ: ${cityName}`);
    return cityName;
  }

  private getDefaultLocation(): Coordinates {
    const defaultCoordinates: Coordinates = {
      latitude: 31.2304,
      longitude: 121.4737
    };
    return defaultCoordinates;
  }
}
