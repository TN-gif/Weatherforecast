import http from '@ohos.net.http';
import { Coordinates, WeatherSnapshot, WeatherApiConfig, WeatherCondition, CurrentWeather, HourlyForecast, DailyForecast, AdviceItem } from '../models/WeatherModels';

interface OpenMeteoCurrentWeather {
  temperature: number;
  windspeed: number;
  winddirection: number;
  weathercode: number;
  time: string;
}

interface OpenMeteoHourlyBlock {
  time: string[];
  temperature_2m: number[];
  precipitation_probability: number[];
}

interface OpenMeteoDailyBlock {
  time: string[];
  temperature_2m_max: number[];
  temperature_2m_min: number[];
  precipitation_probability_max: number[];
  weathercode: number[];
}

interface OpenMeteoResponse {
  current_weather: OpenMeteoCurrentWeather;
  hourly: OpenMeteoHourlyBlock;
  daily: OpenMeteoDailyBlock;
  timezone_abbreviation: string;
  utc_offset_seconds: number;
}

interface RetryConfig {
  readonly maxRetries: number;
  readonly baseDelay: number;
  readonly backoffMultiplier: number;
  readonly timeoutMs: number;
  readonly maxDelay: number;
}

export class WeatherService {
  private readonly config: WeatherApiConfig;
  private readonly retryConfig: RetryConfig = {
    maxRetries: 3,
    baseDelay: 400,
    backoffMultiplier: 2,
    timeoutMs: 20000, // å¢åŠ åˆ°20ç§’ï¼Œé€‚åº”ç½‘ç»œæ¡ä»¶
    maxDelay: 4000
  };

  constructor(config: WeatherApiConfig) {
    this.config = config;
  }

  async fetchWeather(cityId: string, coordinates: Coordinates): Promise<WeatherSnapshot> {
    console.info(`[WeatherService] ========== å¼€å§‹è·å–å¤©æ°”æ•°æ® ==========`);
    console.info(`[WeatherService] åŸå¸‚ID: ${cityId}`);
    console.info(`[WeatherService] åæ ‡: çº¬åº¦=${coordinates.latitude}, ç»åº¦=${coordinates.longitude}`);
    console.info(`[WeatherService] APIé…ç½®: ${JSON.stringify(this.config)}`);
    
    const query: string = this.buildQuery(coordinates);
    console.info(`[WeatherService] å®Œæ•´è¯·æ±‚URL: ${query}`);
    let attempt: number = 1;

    while (attempt <= this.retryConfig.maxRetries) {
      console.info(`[WeatherService] å°è¯•ç¬¬ ${attempt}/${this.retryConfig.maxRetries} æ¬¡è¯·æ±‚`);
      const httpRequest: http.HttpRequest = http.createHttp();
      const startTime = Date.now();
      
      try {
        console.info(`[WeatherService] å¼€å§‹HTTPè¯·æ±‚...`);
        const payload: OpenMeteoResponse = await this.performRequest(httpRequest, query);
        const requestTime = Date.now() - startTime;
        console.info(`[WeatherService] HTTPè¯·æ±‚æˆåŠŸï¼Œè€—æ—¶: ${requestTime}ms`);
        
        console.info(`[WeatherService] å¼€å§‹éªŒè¯å“åº”æ•°æ®...`);
        this.validatePayload(payload);
        console.info(`[WeatherService] æ•°æ®éªŒè¯é€šè¿‡`);
        
        console.info(`[WeatherService] å¼€å§‹è½¬æ¢æ•°æ®æ ¼å¼...`);
        const snapshot = this.mapToSnapshot(cityId, payload);
        console.info(`[WeatherService] ========== å¤©æ°”æ•°æ®è·å–æˆåŠŸ ==========`);
        return snapshot;
      } catch (error) {
        const requestTime = Date.now() - startTime;
        const err = error as Error;
        console.error(`[WeatherService] ç¬¬${attempt}æ¬¡è¯·æ±‚å¤±è´¥ï¼Œè€—æ—¶: ${requestTime}ms`);
        console.error(`[WeatherService] é”™è¯¯ç±»å‹: ${err.name}`);
        console.error(`[WeatherService] é”™è¯¯ä¿¡æ¯: ${err.message}`);
        console.error(`[WeatherService] é”™è¯¯å †æ ˆ: ${err.stack}`);
        
        if (!this.isRetryableError(err) || attempt === this.retryConfig.maxRetries) {
          console.error(`[WeatherService] ========== å¤©æ°”æ•°æ®è·å–æœ€ç»ˆå¤±è´¥ ==========`);
          throw new Error(`Weather fetch failed after ${attempt} attempts: ${err.message}`);
        }
        const delay: number = this.calculateDelay(attempt);
        console.warn(`[WeatherService] å°†åœ¨ ${delay}ms åé‡è¯•...`);
        await this.sleep(delay);
      } finally {
        httpRequest.destroy();
        attempt++;
      }
    }
    throw new Error('WeatherService exhausted retries');
  }

  private buildQuery(coordinates: Coordinates): string {
    return `${this.config.baseUrl}?latitude=${coordinates.latitude}&longitude=${coordinates.longitude}` +
      `&current_weather=true&hourly=temperature_2m,precipitation_probability` +
      `&daily=weathercode,temperature_2m_max,temperature_2m_min,precipitation_probability_max` +
      `&forecast_days=${this.config.dailyCount}&timezone=auto`;
  }

  private async performRequest(httpRequest: http.HttpRequest, query: string): Promise<OpenMeteoResponse> {
    console.info(`[WeatherService] é…ç½®HTTPè¯·æ±‚å‚æ•°...`);
    const requestConfig: http.HttpRequestOptions = {
      method: http.RequestMethod.GET,
      expectDataType: http.HttpDataType.STRING,
      connectTimeout: this.retryConfig.timeoutMs,
      readTimeout: this.retryConfig.timeoutMs
    };
    console.info(`[WeatherService] è¯·æ±‚é…ç½®: ${JSON.stringify(requestConfig)}`);
    
    console.info(`[WeatherService] ç­‰å¾…HTTPå“åº”...`);
    const response: http.HttpResponse = await httpRequest.request(query, requestConfig);
    
    console.info(`[WeatherService] æ”¶åˆ°HTTPå“åº”`);
    console.info(`[WeatherService] å“åº”ç : ${response.responseCode}`);
    console.info(`[WeatherService] å“åº”å¤´: ${JSON.stringify(response.header)}`);
    
    if (response.responseCode !== 200) {
      console.error(`[WeatherService] HTTPé”™è¯¯: ${response.responseCode}`);
      console.error(`[WeatherService] å“åº”å†…å®¹: ${response.result}`);
      throw new Error(`HTTP ${response.responseCode}: ${response.result}`);
    }

    const responseText = response.result as string;
    console.info(`[WeatherService] å“åº”æ•°æ®é•¿åº¦: ${responseText.length} å­—ç¬¦`);
    console.info(`[WeatherService] å“åº”æ•°æ®é¢„è§ˆ: ${responseText.substring(0, 200)}...`);
    
    try {
      const jsonData = JSON.parse(responseText) as OpenMeteoResponse;
      console.info(`[WeatherService] JSONè§£ææˆåŠŸ`);
      return jsonData;
    } catch (parseError) {
      console.error(`[WeatherService] JSONè§£æå¤±è´¥: ${(parseError as Error).message}`);
      console.error(`[WeatherService] åŸå§‹å“åº”: ${responseText}`);
      throw new Error(`JSON parse error: ${(parseError as Error).message}`);
    }
  }

  private validatePayload(payload: OpenMeteoResponse): void {
    if (!payload.current_weather || !payload.hourly || !payload.daily) {
      throw new Error('invalid_payload');
    }
    if (!payload.hourly.temperature_2m || !payload.hourly.time) {
      throw new Error('invalid_hourly_block');
    }
    if (!payload.daily.temperature_2m_max || !payload.daily.time) {
      throw new Error('invalid_daily_block');
    }
  }

  private isRetryableError(error: Error): boolean {
    const message: string = (error.message || '').toLowerCase();
    if (message.includes('404') || message.includes('401') || message.includes('invalid')) {
      return false;
    }
    return true;
  }

  private calculateDelay(attempt: number): number {
    const exponential: number = this.retryConfig.baseDelay * Math.pow(this.retryConfig.backoffMultiplier, attempt - 1);
    const capped: number = Math.min(exponential, this.retryConfig.maxDelay);
    const jitter: number = capped * 0.25 * (Math.random() * 2 - 1);
    return Math.floor(capped + jitter);
  }

  private sleep(duration: number): Promise<void> {
    return new Promise((resolve: () => void) => setTimeout(resolve, duration));
  }

  private mapToSnapshot(cityId: string, payload: OpenMeteoResponse): WeatherSnapshot {
    const condition: WeatherCondition = this.mapWeatherCode(payload.current_weather.weathercode);
    const current: CurrentWeather = {
      temperatureC: payload.current_weather.temperature,
      feelsLikeC: payload.current_weather.temperature,
      humidity: 65,
      windSpeedKph: payload.current_weather.windspeed,
      windDirection: `${payload.current_weather.winddirection.toFixed(0)}Â°`,
      pressureHpa: 1012,
      visibilityKm: 10,
      uvIndex: 4,
      aqi: 45,
      sunrise: '06:10',
      sunset: '18:45',
      condition: condition
    };

    const hourly: HourlyForecast[] = [];
    let index: number = 0;
    while (index < payload.hourly.time.length && index < this.config.hourlyCount) {
      hourly.push({
        time: payload.hourly.time[index],
        temperatureC: payload.hourly.temperature_2m[index],
        precipitationProbability: payload.hourly.precipitation_probability[index],
        iconCode: condition.iconCode,
        description: condition.description
      });
      index++;
    }

    const daily: DailyForecast[] = [];
    let dailyIndex: number = 0;
    while (dailyIndex < payload.daily.time.length && dailyIndex < this.config.dailyCount) {
      const dayCondition: WeatherCondition = this.mapWeatherCode(payload.daily.weathercode[dailyIndex]);
      daily.push({
        date: payload.daily.time[dailyIndex],
        minTempC: payload.daily.temperature_2m_min[dailyIndex],
        maxTempC: payload.daily.temperature_2m_max[dailyIndex],
        iconCode: dayCondition.iconCode,
        description: dayCondition.description,
        precipitationProbability: payload.daily.precipitation_probability_max[dailyIndex]
      });
      dailyIndex++;
    }

    const advice: AdviceItem[] = this.generateAdvice(condition, current);

    const weatherSnapshot: WeatherSnapshot = {
      cityId: cityId,
      lastUpdatedIso: new Date().toISOString(),
      timezoneOffsetMinutes: payload.utc_offset_seconds / 60,
      current: current,
      hourly: hourly,
      daily: daily,
      advice: advice,
      dataSource: 'open-meteo'
    };
    return weatherSnapshot;
  }

  private mapWeatherCode(code: number): WeatherCondition {
    if (code === 0) {
      const sunnyCondition: WeatherCondition = { description: 'æ™´æœ—', iconCode: 'sunny', themeKey: 'sunny', emotion: 'æ™´ç©ºé€‚åˆå‡ºè¡Œ' };
      return sunnyCondition;
    }
    if (code >= 1 && code <= 3) {
      const cloudyCondition: WeatherCondition = { description: 'å¤šäº‘', iconCode: 'cloudy', themeKey: 'sunny', emotion: 'å¤šäº‘ä¹Ÿåˆ«å¿˜äº†è¡¥æ°´' };
      return cloudyCondition;
    }
    if (code >= 45 && code <= 48) {
      const fogCondition: WeatherCondition = { description: 'é›¾éœ¾', iconCode: 'fog', themeKey: 'rainy', emotion: 'èƒ½è§åº¦ä½ï¼Œæ³¨æ„å®‰å…¨' };
      return fogCondition;
    }
    if ((code >= 51 && code <= 67) || (code >= 80 && code <= 82)) {
      const rainyCondition: WeatherCondition = { description: 'å°é›¨', iconCode: 'rainy', themeKey: 'rainy', emotion: 'é›¨å¤©é…å’–å•¡æ›´æœ‰å‘³é“' };
      return rainyCondition;
    }
    if (code >= 71 && code <= 77) {
      const snowCondition: WeatherCondition = { description: 'é™é›ª', iconCode: 'snow', themeKey: 'snow', emotion: 'é›ªå¤©è¯·æ³¨æ„ä¿æš–' };
      return snowCondition;
    }
    const nightCondition: WeatherCondition = { description: 'å¤œé—´', iconCode: 'night', themeKey: 'night', emotion: 'å¤œè‰²æ¸©æŸ”ï¼Œæ—©ç‚¹ä¼‘æ¯' };
    return nightCondition;
  }

  private generateAdvice(condition: WeatherCondition, current: CurrentWeather): AdviceItem[] {
    const rows: AdviceItem[] = [
      {
        id: 'advice_weather',
        icon: 'ğŸŒ¤',
        tone: 'äº²å’Œ',
        content: condition.emotion
      },
      {
        id: 'advice_uv',
        icon: 'ğŸ§´',
        tone: 'ä½“è´´',
        content: current.uvIndex > 6 ? 'ç´«å¤–çº¿å¼ºï¼Œè®°å¾—é˜²æ™’' : 'ç´«å¤–çº¿æ¸©å’Œï¼Œæ”¾å¿ƒå‡ºè¡Œ'
      },
      {
        id: 'advice_aqi',
        icon: 'ğŸ˜·',
        tone: 'æé†’',
        content: current.aqi > 100 ? 'ç©ºæ°”ä¸€èˆ¬ï¼Œå‡ºé—¨å¯å¤‡å£ç½©' : 'ç©ºæ°”è´¨é‡ä¸é”™ï¼Œå°½æƒ…å‘¼å¸'
      }
    ];
    return rows;
  }
}
