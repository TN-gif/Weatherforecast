import http from '@ohos.net.http';
import { Coordinates, WeatherSnapshot, WeatherApiConfig, WeatherCondition, CurrentWeather, HourlyForecast, DailyForecast, AdviceItem, RainForecast, WeatherAlert } from '../models/WeatherModels';
import { DesignSystem } from '../../common/theme/DesignSystem';

// å’Œé£å¤©æ°”APIå“åº”æ¥å£ - ä½¿ç”¨interfaceè€Œéå¯¹è±¡å­—é¢é‡
interface QWeatherNowData {
  temp: string;
  feelsLike: string;
  text: string;
  wind360: string;
  windDir: string;
  windScale: string;
  windSpeed: string;
  humidity: string;
  precip: string;
  pressure: string;
  vis: string;
  cloud: string;
  dew: string;
}

interface QWeatherNow {
  code: string;
  now: QWeatherNowData;
}

interface QWeatherHourlyItem {
  fxTime: string;
  temp: string;
  pop: string;
  text: string;
  wind360: string;
  windDir: string;
  windSpeed: string;
}

interface QWeatherHourly {
  code: string;
  hourly: QWeatherHourlyItem[];
}

interface QWeatherDailyItem {
  fxDate: string;
  tempMax: string;
  tempMin: string;
  textDay: string;
  textNight: string;
  iconDay: string;
  iconNight: string;
  precip: string;
  sunrise: string;  // æ—¥å‡ºæ—¶é—´ HH:mm
  sunset: string;   // æ—¥è½æ—¶é—´ HH:mm
  uvIndex: string;  // ç´«å¤–çº¿æŒ‡æ•°
  humidity: string; // æ¹¿åº¦
  pressure: string; // æ°”å‹
  vis: string;      // èƒ½è§åº¦
}

interface QWeatherDaily {
  code: string;
  daily: QWeatherDailyItem[];
}

interface QWeatherWarningItem {
  id: string;
  sender: string;
  pubTime: string;
  title: string;
  startTime: string;
  endTime: string;
  status: string;
  level: string;
  type: string;
  typeName: string;
  text: string;
  related: string;
}

interface QWeatherWarning {
  code: string;
  warning: QWeatherWarningItem[];
}

interface QWeatherMinutelyItem {
  fxTime: string;
  precip: string;
  type: string;
}

// å¤©æ°”æŒ‡æ•°å“åº”æ¥å£
interface QWeatherIndicesDaily {
  date: string;
  type: string;  // '5' è¡¨ç¤ºç´«å¤–çº¿æŒ‡æ•°
  name: string;
  level: string; // 1-5 çº§åˆ«
  category: string;
  text: string;
}

interface QWeatherIndices {
  code: string;
  daily: QWeatherIndicesDaily[];
}

interface QWeatherMinutely {
  code: string;
  summary: string;
  minutely: QWeatherMinutelyItem[];
}

// ç©ºæ°”è´¨é‡é¦–è¦æ±¡æŸ“ç‰©
interface QWeatherPrimaryPollutant {
  code: string;
  name: string;
  fullName: string;
}

// ç©ºæ°”è´¨é‡AQIæŒ‡æ•°
interface QWeatherAirIndex {
  code: string;  // æŒ‡æ•°ç±»å‹ï¼šus-epa, qaqiç­‰
  name: string;
  aqi: number;   // AQIå€¼
  aqiDisplay: string;
  level: string;
  category: string;
  primaryPollutant?: QWeatherPrimaryPollutant;
}

// æ±¡æŸ“ç‰©æµ“åº¦
interface QWeatherConcentration {
  value: number;
  unit: string;
}

// ç©ºæ°”è´¨é‡æ±¡æŸ“ç‰©
interface QWeatherPollutant {
  code: string;
  name: string;
  fullName: string;
  concentration: QWeatherConcentration;
}

// ç©ºæ°”è´¨é‡å…ƒæ•°æ®
interface QWeatherAirMetadata {
  tag: string;
}

// ç›‘æµ‹ç«™ä¿¡æ¯
interface QWeatherStation {
  id: string;
  name: string;
}

// ç©ºæ°”è´¨é‡è¿”å›æ•°æ®
interface QWeatherAir {
  metadata?: QWeatherAirMetadata;
  indexes: QWeatherAirIndex[];  // å¤šä¸ªAQIæŒ‡æ•°
  pollutants?: QWeatherPollutant[]; // æ±¡æŸ“ç‰©æµ“åº¦
  stations?: QWeatherStation[];
}

export class QWeatherService {
  private readonly config: WeatherApiConfig;
  private readonly timeoutMs: number = 15000;

  constructor(config: WeatherApiConfig) {
    this.config = config;
  }

  async fetchWeather(cityId: string, coordinates: Coordinates, timezoneOffsetMinutes?: number): Promise<WeatherSnapshot> {
    console.info(`[QWeatherService] ========== å¼€å§‹è·å–å’Œé£å¤©æ°”æ•°æ® ==========`);
    console.info(`[QWeatherService] ğŸ™ï¸ åŸå¸‚ID: ${cityId}`);
    console.info(`[QWeatherService] ğŸ“ åæ ‡: ${coordinates.latitude.toFixed(4)},${coordinates.longitude.toFixed(4)}`);
    if (timezoneOffsetMinutes !== undefined) {
      console.info(`[QWeatherService] ğŸ•’ æ—¶åŒºåç§»: ${timezoneOffsetMinutes}åˆ†é’Ÿ (UTC${timezoneOffsetMinutes >= 0 ? '+' : ''}${timezoneOffsetMinutes / 60})`);
    }
    const startTime = Date.now();

    try {
      const location = `${coordinates.longitude},${coordinates.latitude}`;
      console.info(`[QWeatherService] ğŸš€ å‘èµ·7ä¸ªå¹¶å‘è¯·æ±‚ (Now, Hourly, Daily, Warning, Minutely, Air, Indices)...`);
      
      const allResults = await Promise.all([
        this.fetchNow(location),
        this.fetchHourly(location),
        this.fetchDaily(location),
        this.fetchWarning(location),
        this.fetchMinutely(location),
        this.fetchAir(location),
        this.fetchIndices(location)
      ]);

      console.info(`[QWeatherService] âœ… æ‰€æœ‰å¹¶å‘è¯·æ±‚å®Œæˆï¼Œè€—æ—¶: ${Date.now() - startTime}ms`);

      const nowData = allResults[0];
      const hourlyData = allResults[1];
      const dailyData = allResults[2];
      const warningData = allResults[3];
      const minutelyData = allResults[4];
      const airData = allResults[5];
      const indicesData = allResults[6];

      // è°ƒè¯•ï¼šæ£€æŸ¥è¿”å›æ•°æ®ç»“æ„
      console.debug(`[QWeatherService] ğŸ“Š æ•°æ®ç»“æ„æ£€æŸ¥:`);
      console.debug(`  - nowData: ${nowData ? 'OK' : 'NULL'}, has now: ${nowData && nowData.now ? 'YES' : 'NO'}`);
      console.debug(`  - hourlyData: ${hourlyData ? 'OK' : 'NULL'}, has hourly: ${hourlyData && hourlyData.hourly ? 'YES' : 'NO'}`);
      console.debug(`  - dailyData: ${dailyData ? 'OK' : 'NULL'}, has daily: ${dailyData && dailyData.daily ? 'YES' : 'NO'}`);
      console.debug(`  - warningData: ${warningData ? 'OK' : 'NULL'}`);
      console.debug(`  - minutelyData: ${minutelyData ? 'OK' : 'NULL'}`);
      console.debug(`  - airData: ${airData ? 'OK' : 'NULL'}, has indexes: ${airData && airData.indexes ? 'YES (' + airData.indexes.length + ')' : 'NO'}`);
      console.debug(`  - indicesData: ${indicesData ? 'OK' : 'NULL'}, has daily: ${indicesData && indicesData.daily ? 'YES (' + indicesData.daily.length + ')' : 'NO'}`);

      console.debug(`[QWeatherService] å¼€å§‹æ˜ å°„æ•°æ®æ¨¡å‹...`);
      const snapshot = this.mapToSnapshot(cityId, nowData, hourlyData, dailyData, warningData, minutelyData, airData, indicesData, timezoneOffsetMinutes);
      console.info(`[QWeatherService] ========== å’Œé£å¤©æ°”æ•°æ®è·å–æˆåŠŸ ==========`);
      return snapshot;
    } catch (error) {
      console.error(`[QWeatherService] âŒ è·å–å¤±è´¥ (${Date.now() - startTime}ms): ${(error as Error).message}`);
      throw new Error(`QWeatherService failed: ${(error as Error).message}`);
    }
  }

  private async fetchNow(location: string): Promise<QWeatherNow> {
    const url = `${this.config.baseUrl}/v7/weather/now?location=${location}&key=${this.config.apiKey}`;
    return await this.request<QWeatherNow>(url, 'weather/now');
  }

  private async fetchHourly(location: string): Promise<QWeatherHourly> {
    const url = `${this.config.baseUrl}/v7/weather/24h?location=${location}&key=${this.config.apiKey}`;
    return await this.request<QWeatherHourly>(url, 'weather/24h');
  }

  private async fetchDaily(location: string): Promise<QWeatherDaily> {
    const url = `${this.config.baseUrl}/v7/weather/7d?location=${location}&key=${this.config.apiKey}`;
    return await this.request<QWeatherDaily>(url, 'weather/7d');
  }

  private async fetchWarning(location: string): Promise<QWeatherWarning> {
    // è§£æç»çº¬åº¦ï¼šlocationæ ¼å¼ä¸º "ç»åº¦,çº¬åº¦"
    const coords = location.split(',');
    const longitude = coords[0];
    const latitude = coords[1];
    // å®˜æ–¹æ–‡æ¡£ï¼š/weatheralert/v1/current/{latitude}/{longitude}
    const url = `${this.config.baseUrl}/weatheralert/v1/current/${latitude}/${longitude}?key=${this.config.apiKey}`;
    return await this.request<QWeatherWarning>(url, 'warning/now');
  }

  private async fetchMinutely(location: string): Promise<QWeatherMinutely> {
    const url = `${this.config.baseUrl}/v7/minutely/5m?location=${location}&key=${this.config.apiKey}`;
    return await this.request<QWeatherMinutely>(url, 'minutely/5m');
  }

  private async fetchIndices(location: string): Promise<QWeatherIndices> {
    // type=5 è¡¨ç¤ºç´«å¤–çº¿æŒ‡æ•°
    const url = `${this.config.baseUrl}/v7/indices/1d?location=${location}&type=5&key=${this.config.apiKey}`;
    return await this.request<QWeatherIndices>(url, 'indices/1d');
  }

  private async fetchAir(location: string): Promise<QWeatherAir> {
    // è§£æç»çº¬åº¦ï¼šlocationæ ¼å¼ä¸º "ç»åº¦,çº¬åº¦"
    const coords = location.split(',');
    const longitude = coords[0];
    const latitude = coords[1];
    // å®˜æ–¹æ–‡æ¡£ï¼š/airquality/v1/current/{latitude}/{longitude}
    const url = `${this.config.baseUrl}/airquality/v1/current/${latitude}/${longitude}?key=${this.config.apiKey}`;
    return await this.request<QWeatherAir>(url, 'air/now');
  }

  private async request<T>(url: string, endpoint: string): Promise<T> {
    const httpRequest = http.createHttp();
    const startTime = Date.now();
    try {
      console.debug(`[QWeatherService] ğŸ“¤ è¯·æ±‚ ${endpoint}...`);
      const response = await httpRequest.request(url, {
        method: http.RequestMethod.GET,
        expectDataType: http.HttpDataType.STRING,
        connectTimeout: this.timeoutMs,
        readTimeout: this.timeoutMs
      });

      if (response.responseCode !== 200) {
        console.error(`[QWeatherService] âŒ ${endpoint} HTTPé”™è¯¯: ${response.responseCode}`);
        throw new Error(`HTTP ${response.responseCode}: ${response.result}`);
      }

      const data = JSON.parse(response.result as string) as T;
      console.debug(`[QWeatherService] âœ… ${endpoint} æˆåŠŸ (${Date.now() - startTime}ms)`);
      return data;
    } catch (error) {
      console.error(`[QWeatherService] âŒ ${endpoint} å¤±è´¥ (${Date.now() - startTime}ms): ${(error as Error).message}`);
      throw new Error(`${endpoint} request failed: ${(error as Error).message}`);
    } finally {
      httpRequest.destroy();
    }
  }

  private mapToSnapshot(
    cityId: string,
    nowData: QWeatherNow,
    hourlyData: QWeatherHourly,
    dailyData: QWeatherDaily,
    warningData: QWeatherWarning,
    minutelyData: QWeatherMinutely,
    airData: QWeatherAir,
    indicesData: QWeatherIndices,
    timezoneOffsetMinutes?: number
  ): WeatherSnapshot {
    const condition = this.mapWeatherText(nowData.now.text);
    
    // å®‰å…¨è·å–ç©ºæ°”è´¨é‡æ•°æ®ï¼Œå¤„ç†APIè¿”å›æ ¼å¼
    let aqiValue = 0;
    try {
      if (airData && airData.indexes && airData.indexes.length > 0) {
        // ä¼˜å…ˆä½¿ç”¨us-epaæ ‡å‡†çš„AQI
        const usEpaIndex = airData.indexes.find(index => index.code === 'us-epa');
        if (usEpaIndex) {
          aqiValue = Math.round(usEpaIndex.aqi);
        } else {
          // å¦‚æœæ²¡æœ‰us-epaï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ªå¯ç”¨çš„AQI
          aqiValue = Math.round(airData.indexes[0].aqi);
        }
        console.debug(`[QWeatherService] ğŸ“Š æå–AQIå€¼: ${aqiValue} (æ¥æº: ${usEpaIndex ? 'us-epa' : airData.indexes[0].code})`);
      }
    } catch (error) {
      console.warn(`[QWeatherService] âš ï¸ ç©ºæ°”è´¨é‡æ•°æ®è§£æå¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å€¼: ${error}`);
    }
    
    // å®‰å…¨è·å–ç´«å¤–çº¿æŒ‡æ•°æ•°æ®
    let uvIndex = 0;
    try {
      if (indicesData && indicesData.code === '200' && indicesData.daily && indicesData.daily.length > 0) {
        const uvData = indicesData.daily.find(item => item.type === '5');
        if (uvData) {
          uvIndex = parseInt(uvData.level); // çº§åˆ« 1-5
          console.info(`[QWeatherService] âœ… ç´«å¤–çº¿æŒ‡æ•°è·å–æˆåŠŸ: ${uvIndex} (${uvData.category}) - ${uvData.text}`);
        } else {
          console.warn(`[QWeatherService] âš ï¸ æŒ‡æ•°æ•°æ®ä¸­æœªæ‰¾åˆ°type='5'çš„ç´«å¤–çº¿æ•°æ®`);
        }
      } else {
        console.warn(`[QWeatherService] âš ï¸ æŒ‡æ•°æ•°æ®æ— æ•ˆ: code=${indicesData?.code}, dailyå­˜åœ¨=${!!indicesData?.daily}, dailyé•¿åº¦=${indicesData?.daily?.length}`);
      }
    } catch (error) {
      console.warn(`[QWeatherService] âš ï¸ ç´«å¤–çº¿æŒ‡æ•°æ•°æ®è§£æå¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å€¼: ${error}`);
    }
    
    // âœ… ä»æ¯æ—¥é¢„æŠ¥æ•°æ®ä¸­æå–æ—¥å‡ºæ—¥è½æ—¶é—´ï¼ˆç¬¬ä¸€å¤©ï¼‰
    let sunrise = '06:00';
    let sunset = '18:00';
    if (dailyData && dailyData.daily && dailyData.daily.length > 0) {
      const todayData = dailyData.daily[0];
      console.info(`[QWeatherService] ğŸ“… ä»Šæ—¥é¢„æŠ¥æ•°æ®: sunrise=${todayData.sunrise}, sunset=${todayData.sunset}`);
      if (todayData.sunrise) sunrise = todayData.sunrise;
      if (todayData.sunset) sunset = todayData.sunset;
      console.info(`[QWeatherService] âœ… æ—¥å‡ºæ—¥è½è·å–æˆåŠŸ: ğŸŒ…${sunrise} / ğŸŒ›${sunset}`);
    } else {
      console.warn(`[QWeatherService] âš ï¸ æ¯æ—¥é¢„æŠ¥æ•°æ®æ— æ•ˆï¼Œä½¿ç”¨é»˜è®¤å€¼`);
    }
    
    const current: CurrentWeather = {
      temperatureC: parseFloat(nowData.now.temp),
      feelsLikeC: parseFloat(nowData.now.feelsLike),
      humidity: parseInt(nowData.now.humidity),
      windSpeedKph: parseFloat(nowData.now.windSpeed),
      windDirection: nowData.now.windDir,
      pressureHpa: parseInt(nowData.now.pressure),
      visibilityKm: parseInt(nowData.now.vis),
      uvIndex: uvIndex,  // âœ… ä½¿ç”¨çœŸå®ç´«å¤–çº¿æŒ‡æ•°æ•°æ®
      aqi: aqiValue,
      sunrise: sunrise,  // âœ… ä½¿ç”¨æ¯æ—¥é¢„æŠ¥ä¸­çš„çœŸå®æ—¥å‡ºæ—¶é—´
      sunset: sunset,    // âœ… ä½¿ç”¨æ¯æ—¥é¢„æŠ¥ä¸­çš„çœŸå®æ—¥è½æ—¶é—´
      condition: condition
    };

    const hourly: HourlyForecast[] = hourlyData.hourly.slice(0, this.config.hourlyCount).map((h: QWeatherHourlyItem): HourlyForecast => {
      const hourlyItem: HourlyForecast = {
        time: h.fxTime,
        temperatureC: parseFloat(h.temp),
        precipitationProbability: parseInt(h.pop),
        iconCode: this.mapWeatherText(h.text).iconCode,
        description: h.text
      };
      return hourlyItem;
    });

    const daily: DailyForecast[] = dailyData.daily.slice(0, this.config.dailyCount).map((d: QWeatherDailyItem): DailyForecast => {
      // âš ï¸ å’Œé£å¤©æ°”æ¯æ—¥é¢„æŠ¥APIä¸åŒ…å«popï¼ˆé™æ°´æ¦‚ç‡ï¼‰å­—æ®µ
      // åªæœ‰precipï¼ˆé™æ°´é‡ï¼‰å­—æ®µï¼Œæ ¹æ®é™æ°´é‡ä¼°ç®—æ¦‚ç‡
      const precipVal = parseFloat(d.precip);
      let precipProbability = 0;
      if (precipVal > 10) { // å¤§é›¨
        precipProbability = 90;
      } else if (precipVal > 5) { // ä¸­é›¨
        precipProbability = 70;
      } else if (precipVal > 0.1) { // å°é›¨
        precipProbability = 50;
      } else { // æ— é™æ°´
        precipProbability = 10;
      }
      
      const dailyItem: DailyForecast = {
        date: d.fxDate,
        minTempC: parseFloat(d.tempMin),
        maxTempC: parseFloat(d.tempMax),
        iconCode: this.mapWeatherText(d.textDay).iconCode,
        description: d.textDay,
        precipitationProbability: precipProbability  // âœ… æ ¹æ®é™æ°´é‡ä¼°ç®—
      };
      return dailyItem;
    });

    const alerts = this.mapWarnings(warningData);
    const rainForecast = this.mapMinutely(minutelyData);
    const advice = this.generateAdvice(condition, current);

    // ğŸ”§ ä¿®å¤ï¼šä½¿ç”¨ä¼ å…¥çš„å®é™…æ—¶åŒºåç§»é‡ï¼Œå¦‚æœæœªæä¾›åˆ™ä½¿ç”¨UTC+8ä½œä¸ºé»˜è®¤å€¼
    const actualTimezoneOffset = timezoneOffsetMinutes !== undefined ? timezoneOffsetMinutes : 480;
    console.info(`[QWeatherService] ğŸ•’ ä½¿ç”¨æ—¶åŒºåç§»: ${actualTimezoneOffset}åˆ†é’Ÿ (UTC${actualTimezoneOffset >= 0 ? '+' : ''}${actualTimezoneOffset / 60})`);
    
    const snapshot: WeatherSnapshot = {
      cityId: cityId,
      lastUpdatedIso: new Date().toISOString(),
      timezoneOffsetMinutes: actualTimezoneOffset,
      current: current,
      hourly: hourly,
      daily: daily,
      advice: advice,
      alerts: alerts,
      rainForecast: rainForecast,
      dataSource: 'qweather'
    };
    return snapshot;
  }

  private mapWeatherText(text: string): WeatherCondition {
    if (text.includes('æ™´')) {
      const condition: WeatherCondition = { 
        description: text, 
        iconCode: 'sunny', 
        themeKey: 'sunny', 
        emotion: 'é˜³å…‰æ˜åªšï¼Œé€‚åˆå‡ºè¡Œ' 
      };
      return condition;
    }
    if (text.includes('äº‘') || text.includes('é˜´')) {
      const condition: WeatherCondition = { 
        description: text, 
        iconCode: 'cloudy', 
        themeKey: 'sunny', 
        emotion: 'å¤šäº‘å¤©æ°”ï¼Œè®°å¾—è¡¥æ°´' 
      };
      return condition;
    }
    if (text.includes('é›¨')) {
      const condition: WeatherCondition = { 
        description: text, 
        iconCode: 'rainy', 
        themeKey: 'rainy', 
        emotion: 'é›¨å¤©è·¯æ»‘ï¼Œæ³¨æ„å®‰å…¨' 
      };
      return condition;
    }
    if (text.includes('é›ª')) {
      const condition: WeatherCondition = { 
        description: text, 
        iconCode: 'snow', 
        themeKey: 'snow', 
        emotion: 'é›ªå¤©æ³¨æ„ä¿æš–' 
      };
      return condition;
    }
    if (text.includes('é›·')) {
      const condition: WeatherCondition = { 
        description: text, 
        iconCode: 'storm', 
        themeKey: 'rainy', 
        emotion: 'é›·é›¨å¤©æ°”ï¼Œå‡å°‘å¤–å‡º' 
      };
      return condition;
    }
    const condition: WeatherCondition = { 
      description: text, 
      iconCode: 'sunny', 
      themeKey: 'sunny', 
      emotion: 'å¤©æ°”ä¸é”™' 
    };
    return condition;
  }

  private mapWarnings(warningData: QWeatherWarning): WeatherAlert[] {
    if (warningData.code !== '200' || !warningData.warning || warningData.warning.length === 0) {
      return [];
    }

    return warningData.warning.map((w: QWeatherWarningItem): WeatherAlert => {
      const severity = this.mapWarningLevel(w.level);
      const alert: WeatherAlert = {
        id: w.id,
        severity: severity,
        title: w.typeName,
        description: w.text,
        startTime: w.startTime,
        endTime: w.endTime,
        iconResource: DesignSystem.IconResources.RAIN
      };
      return alert;
    });
  }

  private mapWarningLevel(level: string): 'warning' | 'watch' | 'advisory' {
    if (level.includes('çº¢') || level.includes('Red')) return 'warning';
    if (level.includes('æ©™') || level.includes('Orange')) return 'warning';
    if (level.includes('é»„') || level.includes('Yellow')) return 'watch';
    return 'advisory';
  }

  private mapMinutely(minutelyData: QWeatherMinutely): RainForecast[] {
    if (minutelyData.code !== '200' || !minutelyData.minutely || minutelyData.minutely.length === 0) {
      return [];
    }

    return minutelyData.minutely.map((item: QWeatherMinutelyItem, index: number): RainForecast => {
      const precip = parseFloat(item.precip);
      const forecast: RainForecast = {
        timeMinutes: index * 5,
        probability: precip > 0 ? 100 : 0,
        intensity: precip < 0.5 ? 'light' : (precip < 2 ? 'moderate' : 'heavy')
      };
      return forecast;
    });
  }

  private generateAdvice(condition: WeatherCondition, current: CurrentWeather): AdviceItem[] {
    const advice: AdviceItem[] = [
      {
        id: 'advice_weather',
        icon: 'weather',
        tone: 'å¤©æ°”æç¤º',
        content: condition.emotion,
        priority: 1
      },
      {
        id: 'advice_temp',
        icon: 'sun',
        tone: 'æ¸©åº¦å»ºè®®',
        content: current.temperatureC > 30 ? 'å¤©æ°”ç‚çƒ­ï¼Œæ³¨æ„é˜²æš‘' : current.temperatureC < 10 ? 'å¤©æ°”å¯’å†·ï¼Œæ³¨æ„ä¿æš–' : 'æ¸©åº¦é€‚å®œï¼Œèˆ’é€‚å‡ºè¡Œ',
        priority: 2
      },
      {
        id: 'advice_aqi',
        icon: 'wind',
        tone: 'ç©ºæ°”è´¨é‡',
        content: current.aqi > 100 ? 'ç©ºæ°”è´¨é‡ä¸€èˆ¬ï¼Œå‡å°‘æˆ·å¤–æ´»åŠ¨' : 'ç©ºæ°”è´¨é‡è‰¯å¥½ï¼Œé€‚åˆæˆ·å¤–è¿åŠ¨',
        priority: 3
      }
    ];
    return advice;
  }
}
