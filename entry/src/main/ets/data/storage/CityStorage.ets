import relationalStore from '@ohos.data.relationalStore';
import type common from '@ohos.app.ability.common';
import { AppConstants } from '../../common/constants/AppConstants';
import { City, Coordinates } from '../models/WeatherModels';

export class CityStorage {
  private static instance: CityStorage | null = null;
  private rdbStore: relationalStore.RdbStore | null = null;
  private readonly currentSchemaVersion: number = 2;
  private readonly tempDbName: string = 'temp_weather_db';

  private constructor() {}

  static getInstance(): CityStorage {
    if (CityStorage.instance === null) {
      CityStorage.instance = new CityStorage();
    }
    return CityStorage.instance;
  }

  async init(context: common.UIAbilityContext): Promise<void> {
    if (this.rdbStore) {
      console.debug('[CityStorage] âš ï¸ æ•°æ®åº“å·²åˆå§‹åŒ–ï¼Œè·³è¿‡');
      return;
    }
    
    console.info('[CityStorage] âš™ï¸ å¼€å§‹åˆå§‹åŒ–æ•°æ®åº“...');
    const config: relationalStore.StoreConfig = {
      name: AppConstants.RDB_NAME,
      securityLevel: relationalStore.SecurityLevel.S1,
      encrypt: false
    };
    
    try {
      const startTime = Date.now();
      this.rdbStore = await relationalStore.getRdbStore(context, config);
      console.info(`[CityStorage] ğŸ“‚ RdbStoreè·å–æˆåŠŸï¼Œè€—æ—¶: ${Date.now() - startTime}ms`);
      
      // æ£€æŸ¥æ•°æ®åº“å®Œæ•´æ€§
      await this.checkIntegrity();
      
      // æ‰§è¡Œæ•°æ®åº“è¿ç§»
      await this.performMigration();
      
      // ç¡®ä¿è¡¨ç»“æ„
      await this.ensureSchema();
      
      console.info('[CityStorage] âœ… æ•°æ®åº“åˆå§‹åŒ–æµç¨‹å…¨éƒ¨å®Œæˆ');
    } catch (error) {
      console.error('[CityStorage] âŒ æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥ï¼Œå°è¯•æ‰§è¡Œä¿®å¤æµç¨‹...', error);
      await this.repairDatabase(context, config);
    }
  }

  private async checkIntegrity(): Promise<void> {
    if (!this.rdbStore) {
      throw new Error('Database not initialized');
    }
    
    try {
      console.info('[CityStorage] Checking database integrity...');
      const result = await this.rdbStore.querySql('PRAGMA integrity_check;');
      
      if (result.rowCount > 0) {
        result.goToFirstRow();
        const integrityResult = result.getString(0);
        
        if (integrityResult !== 'ok') {
          console.error(`[CityStorage] Database integrity check failed: ${integrityResult}`);
          throw new Error('Database integrity compromised');
        }
      }
      
      console.info('[CityStorage] Database integrity check passed');
    } catch (error) {
      console.error('[CityStorage] Integrity check failed:', error);
      throw error instanceof Error ? error : new Error(String(error));
    }
  }

  private async performMigration(): Promise<void> {
    if (!this.rdbStore) {
      return;
    }
    
    console.info('[CityStorage] Checking for database migrations...');
    
    try {
      const currentVersion = await this.getCurrentSchemaVersion();
      console.info(`[CityStorage] Current schema version: ${currentVersion}, target: ${this.currentSchemaVersion}`);
      
      if (currentVersion < this.currentSchemaVersion) {
        console.info('[CityStorage] Performing database migration...');
        
        if (currentVersion < 2) {
          await this.migrateV1ToV2();
        }
        
        await this.updateSchemaVersion(this.currentSchemaVersion);
        console.info('[CityStorage] Database migration completed');
      }
    } catch (error) {
      console.error('[CityStorage] Migration failed:', error);
      throw error instanceof Error ? error : new Error(String(error));
    }
  }

  private async migrateV1ToV2(): Promise<void> {
    if (!this.rdbStore) {
      return;
    }
    
    console.info('[CityStorage] Migrating from V1 to V2...');
    
    try {
      // æ£€æŸ¥æ˜¯å¦éœ€è¦æ·»åŠ æ–°åˆ—
      const tableInfo = await this.rdbStore.querySql(`PRAGMA table_info(${AppConstants.CITY_TABLE});`);
      let hasTimeZoneColumn = false;
      
      if (tableInfo.rowCount > 0) {
        tableInfo.goToFirstRow();
        do {
          const columnName = tableInfo.getString(1);
          if (columnName === 'timeZoneOffsetMinutes') {
            hasTimeZoneColumn = true;
            break;
          }
        } while (tableInfo.goToNextRow());
      }
      
      if (!hasTimeZoneColumn) {
        await this.rdbStore.executeSql(
          `ALTER TABLE ${AppConstants.CITY_TABLE} ADD COLUMN timeZoneOffsetMinutes INTEGER DEFAULT 0`
        );
        console.info('[CityStorage] Added timeZoneOffsetMinutes column');
      }
    } catch (error) {
      console.error('[CityStorage] V1 to V2 migration failed:', error);
      throw error instanceof Error ? error : new Error(String(error));
    }
  }

  private async repairDatabase(context: common.UIAbilityContext, config: relationalStore.StoreConfig): Promise<void> {
    console.info('[CityStorage] Starting database repair...');
    
    try {
      // å°è¯•å¤‡ä»½ç°æœ‰æ•°æ®
      let backupData: City[] = [];
      if (this.rdbStore) {
        try {
          backupData = await this.getAllCitiesRaw();
          console.info(`[CityStorage] Backed up ${backupData.length} cities`);
        } catch (backupError) {
          console.warn('[CityStorage] Failed to backup data:', backupError);
        }
      }
      
      // åˆ é™¤æŸåçš„æ•°æ®åº“
      if (this.rdbStore) {
        this.rdbStore = null;
      }
      await relationalStore.deleteRdbStore(context, AppConstants.RDB_NAME);
      
      // é‡æ–°åˆ›å»ºæ•°æ®åº“
      this.rdbStore = await relationalStore.getRdbStore(context, config);
      await this.ensureSchema();
      
      // æ¢å¤æ•°æ®
      if (backupData.length > 0) {
        console.info('[CityStorage] Restoring backup data...');
        await this.restoreData(backupData);
        console.info('[CityStorage] Data restoration completed');
      }
      
      console.info('[CityStorage] Database repair completed successfully');
    } catch (error) {
      console.error('[CityStorage] Database repair failed:', error);
      throw error instanceof Error ? error : new Error(String(error));
    }
  }

  private async getAllCitiesRaw(): Promise<City[]> {
    if (!this.rdbStore) {
      return [];
    }
    
    try {
      const resultSet = await this.rdbStore.querySql(`SELECT * FROM ${AppConstants.CITY_TABLE} ORDER BY displayOrder`);
      const cities: City[] = [];
      
      if (resultSet.rowCount > 0) {
        resultSet.goToFirstRow();
        do {
          const city = this.mapResultSetToCity(resultSet);
          if (city) {
            cities.push(city);
          }
        } while (resultSet.goToNextRow());
      }
      
      return cities;
    } catch (error) {
      console.error('[CityStorage] Failed to get raw cities:', error);
      return [];
    }
  }

  private async restoreData(cities: City[]): Promise<void> {
    if (!this.rdbStore || cities.length === 0) {
      return;
    }
    
    try {
      await this.rdbStore.executeSql(`DELETE FROM ${AppConstants.CITY_TABLE}`);
      
      let displayOrder = 0;
      for (const city of cities) {
        const valueBucket: relationalStore.ValuesBucket = {
          id: city.id,
          name: city.name,
          country: city.country,
          latitude: city.coordinates.latitude,
          longitude: city.coordinates.longitude,
          source: city.source,
          videoTheme: city.videoTheme,
          timeZoneOffsetMinutes: city.timeZoneOffsetMinutes,
          displayOrder: displayOrder++
        };
        
        await this.rdbStore.insert(AppConstants.CITY_TABLE, valueBucket);
      }
      
      console.info(`[CityStorage] Restored ${cities.length} cities`);
    } catch (error) {
      console.error('[CityStorage] Data restoration failed:', error);
      throw error instanceof Error ? error : new Error(String(error));
    }
  }

  private async getCurrentSchemaVersion(): Promise<number> {
    if (!this.rdbStore) {
      return 0;
    }
    
    try {
      // ç¡®ä¿å…ƒæ•°æ®è¡¨å­˜åœ¨
      await this.createMetadataTable();
      
      const resultSet = await this.rdbStore.querySql(
        `SELECT value FROM ${AppConstants.METADATA_TABLE} WHERE key = 'schema_version'`
      );
      
      if (resultSet.rowCount > 0) {
        resultSet.goToFirstRow();
        return parseInt(resultSet.getString(0)) || 1;
      }
      
      return 1; // é»˜è®¤ç‰ˆæœ¬
    } catch (error) {
      console.warn('[CityStorage] Failed to get schema version:', error);
      return 1;
    }
  }

  private async updateSchemaVersion(version: number): Promise<void> {
    if (!this.rdbStore) {
      return;
    }
    
    const valueBucket: relationalStore.ValuesBucket = {
      'key': 'schema_version',
      'value': version.toString()
    };
    
    try {
      await this.rdbStore.insert(AppConstants.METADATA_TABLE, valueBucket, relationalStore.ConflictResolution.ON_CONFLICT_REPLACE);
      console.info(`[CityStorage] Schema version updated to ${version}`);
    } catch (error) {
      console.error('[CityStorage] Failed to update schema version:', error);
    }
  }

  private async createMetadataTable(): Promise<void> {
    if (!this.rdbStore) {
      return;
    }
    
    const sql = `CREATE TABLE IF NOT EXISTS ${AppConstants.METADATA_TABLE} (
      key TEXT PRIMARY KEY,
      value TEXT NOT NULL
    )`;
    
    await this.rdbStore.executeSql(sql);
  }

  private mapResultSetToCity(resultSet: relationalStore.ResultSet): City | null {
    try {
      const coordinates: Coordinates = {
        latitude: resultSet.getDouble(resultSet.getColumnIndex('latitude')),
        longitude: resultSet.getDouble(resultSet.getColumnIndex('longitude'))
      };
      
      return new City(
        resultSet.getString(resultSet.getColumnIndex('id')),
        resultSet.getString(resultSet.getColumnIndex('name')),
        resultSet.getString(resultSet.getColumnIndex('country')),
        coordinates,
        resultSet.getLong(resultSet.getColumnIndex('source')),
        resultSet.getString(resultSet.getColumnIndex('videoTheme')),
        resultSet.getLong(resultSet.getColumnIndex('timeZoneOffsetMinutes'))
      );
    } catch (error) {
      console.error('[CityStorage] Failed to map result set to city:', error);
      return null;
    }
  }

  private async ensureSchema(): Promise<void> {
    if (!this.rdbStore) {
      return;
    }
    
    await this.createMetadataTable();
    await this.createTables();
  }

  private async createTables(): Promise<void> {
    if (!this.rdbStore) {
      return;
    }
    
    await this.rdbStore.executeSql(`
      CREATE TABLE IF NOT EXISTS ${AppConstants.CITY_TABLE} (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        country TEXT NOT NULL,
        latitude REAL NOT NULL,
        longitude REAL NOT NULL,
        source INTEGER NOT NULL,
        videoTheme TEXT NOT NULL,
        timeZoneOffsetMinutes INTEGER NOT NULL DEFAULT 0,
        displayOrder INTEGER NOT NULL DEFAULT 0,
        createdAt INTEGER NOT NULL DEFAULT 0,
        updatedAt INTEGER NOT NULL DEFAULT 0
      )
    `);
  }

  async loadCities(): Promise<City[]> {
    if (!this.rdbStore) {
      console.warn('[CityStorage] âŒ å°è¯•åŠ è½½åŸå¸‚ä½†æ•°æ®åº“æœªåˆå§‹åŒ–');
      return [];
    }
    
    console.info('[CityStorage] ğŸ“– å¼€å§‹ä»æ•°æ®åº“åŠ è½½åŸå¸‚åˆ—è¡¨...');
    const startTime = Date.now();
    
    const predicates: relationalStore.RdbPredicates = new relationalStore.RdbPredicates(AppConstants.CITY_TABLE);
    predicates.orderByAsc('displayOrder');
    
    try {
      const resultSet: relationalStore.ResultSet = await this.rdbStore.query(predicates);
      const cities: City[] = [];
      
      console.debug(`[CityStorage] ğŸ” æŸ¥è¯¢è¿”å›è¡Œæ•°: ${resultSet.rowCount}`);
      
      while (resultSet.goToNextRow()) {
        const city = this.mapResultSetToCity(resultSet);
        if (city) {
          cities.push(city);
        }
      }
      resultSet.close();
      
      console.info(`[CityStorage] âœ… åŸå¸‚åˆ—è¡¨åŠ è½½å®Œæˆï¼Œå…± ${cities.length} æ¡ï¼Œè€—æ—¶: ${Date.now() - startTime}ms`);
      return cities;
    } catch (error) {
      console.error('[CityStorage] âŒ åŠ è½½åŸå¸‚åˆ—è¡¨å¤±è´¥:', error);
      return [];
    }
  }

  async saveCities(cities: City[]): Promise<void> {
    if (!this.rdbStore) {
      console.warn('[CityStorage] âŒ å°è¯•ä¿å­˜åŸå¸‚ä½†æ•°æ®åº“æœªåˆå§‹åŒ–');
      return;
    }
    
    console.info(`[CityStorage] ğŸ’¾ å¼€å§‹ä¿å­˜åŸå¸‚åˆ—è¡¨ï¼Œå…± ${cities.length} æ¡...`);
    const startTime = Date.now();
    
    try {
      // ä½¿ç”¨äº‹åŠ¡ç¡®ä¿åŸå­æ€§
      this.rdbStore.beginTransaction();
      
      await this.rdbStore.executeSql(`DELETE FROM ${AppConstants.CITY_TABLE}`);
      console.debug('[CityStorage] ğŸ§¹ æ—§æ•°æ®å·²æ¸…é™¤');
      
      let displayOrder: number = 0;
      for (const city of cities) {
        const valueBucket: relationalStore.ValuesBucket = {
          id: city.id,
          name: city.name,
          country: city.country,
          latitude: city.coordinates.latitude,
          longitude: city.coordinates.longitude,
          source: city.source,
          videoTheme: city.videoTheme,
          timeZoneOffsetMinutes: city.timeZoneOffsetMinutes,
          displayOrder: displayOrder,
          createdAt: Date.now(),
          updatedAt: Date.now()
        };
        await this.rdbStore.insert(AppConstants.CITY_TABLE, valueBucket);
        displayOrder++;
      }
      
      this.rdbStore.commit();
      console.info(`[CityStorage] âœ… åŸå¸‚åˆ—è¡¨ä¿å­˜æˆåŠŸï¼Œè€—æ—¶: ${Date.now() - startTime}ms`);
    } catch (error) {
      console.error('[CityStorage] âŒ ä¿å­˜åŸå¸‚åˆ—è¡¨å¤±è´¥ï¼Œå›æ»šäº‹åŠ¡:', error);
      this.rdbStore.rollBack();
      throw error instanceof Error ? error : new Error(String(error));
    }
  }
}
