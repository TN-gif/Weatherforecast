import relationalStore from '@ohos.data.relationalStore';
import type common from '@ohos.app.ability.common';
import { AppConstants } from '../../common/constants/AppConstants';
import { WeatherSnapshot } from '../models/WeatherModels';

export class WeatherCacheStorage {
  private static instance: WeatherCacheStorage | null = null;
  private rdbStore: relationalStore.RdbStore | null = null;
  // ğŸ”§ ç¼“å­˜ç‰ˆæœ¬å· - å½“æ•°æ®ç»“æ„æˆ–æ ¼å¼åŒ–é€»è¾‘å˜åŒ–æ—¶é€’å¢æ­¤ç‰ˆæœ¬å·
  private static readonly CACHE_VERSION: number = 2; // ä¿®å¤æ—¥å‡ºæ—¥è½æ ¼å¼åŒ–åæ›´æ–°ç‰ˆæœ¬

  private constructor() {}

  static getInstance(): WeatherCacheStorage {
    if (WeatherCacheStorage.instance === null) {
      WeatherCacheStorage.instance = new WeatherCacheStorage();
    }
    return WeatherCacheStorage.instance;
  }

  async init(context: common.UIAbilityContext): Promise<void> {
    if (this.rdbStore) {
      console.debug('[WeatherCacheStorage] âš ï¸ ç¼“å­˜æ•°æ®åº“å·²åˆå§‹åŒ–ï¼Œè·³è¿‡');
      return;
    }
    console.info('[WeatherCacheStorage] âš™ï¸ åˆå§‹åŒ–ç¼“å­˜æ•°æ®åº“...');
    const config: relationalStore.StoreConfig = {
      name: AppConstants.RDB_NAME,
      securityLevel: relationalStore.SecurityLevel.S1,
      encrypt: false
    };
    try {
      this.rdbStore = await relationalStore.getRdbStore(context, config);
      await this.createTable();
      console.info('[WeatherCacheStorage] âœ… ç¼“å­˜æ•°æ®åº“åˆå§‹åŒ–æˆåŠŸ');
    } catch (error) {
      console.error('[WeatherCacheStorage] âŒ ç¼“å­˜æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥:', error);
    }
  }

  private async createTable(): Promise<void> {
    if (!this.rdbStore) {
      return;
    }
    await this.rdbStore.executeSql(`
      CREATE TABLE IF NOT EXISTS ${AppConstants.WEATHER_TABLE} (
        cityId TEXT PRIMARY KEY,
        payload TEXT NOT NULL,
        lastUpdated INTEGER NOT NULL,
        cacheVersion INTEGER DEFAULT 1
      )
    `);
  }

  async saveSnapshot(snapshot: WeatherSnapshot): Promise<void> {
    if (!this.rdbStore) {
      console.warn('[WeatherCacheStorage] âŒ å°è¯•ä¿å­˜ç¼“å­˜ä½†æ•°æ®åº“æœªåˆå§‹åŒ–');
      return;
    }
    
    console.debug(`[WeatherCacheStorage] ğŸ’¾ ä¿å­˜å¤©æ°”ç¼“å­˜: ${snapshot.cityId} (ç‰ˆæœ¬: ${WeatherCacheStorage.CACHE_VERSION})`);
    const startTime = Date.now();
    
    try {
      const valueBucket: relationalStore.ValuesBucket = {
        cityId: snapshot.cityId,
        payload: JSON.stringify(snapshot),
        lastUpdated: Date.now(),
        cacheVersion: WeatherCacheStorage.CACHE_VERSION
      };
      await this.rdbStore.insert(
        AppConstants.WEATHER_TABLE,
        valueBucket,
        relationalStore.ConflictResolution.ON_CONFLICT_REPLACE
      );
      console.debug(`[WeatherCacheStorage] âœ… ç¼“å­˜ä¿å­˜æˆåŠŸï¼Œè€—æ—¶: ${Date.now() - startTime}ms`);
    } catch (error) {
      console.error(`[WeatherCacheStorage] âŒ ç¼“å­˜ä¿å­˜å¤±è´¥ (${snapshot.cityId}):`, error);
    }
  }

  async loadSnapshot(cityId: string): Promise<WeatherSnapshot | null> {
    if (!this.rdbStore) {
      return null;
    }
    
    console.debug(`[WeatherCacheStorage] ğŸ“– è¯»å–å¤©æ°”ç¼“å­˜: ${cityId}`);
    const startTime = Date.now();
    
    const predicates: relationalStore.RdbPredicates = new relationalStore.RdbPredicates(AppConstants.WEATHER_TABLE);
    predicates.equalTo('cityId', cityId);
    
    try {
      const resultSet: relationalStore.ResultSet = await this.rdbStore.query(predicates);
      try {
        if (!resultSet.goToFirstRow()) {
          console.debug(`[WeatherCacheStorage] âš ï¸ æœªæ‰¾åˆ°ç¼“å­˜: ${cityId}`);
          return null;
        }
        
        // ğŸ”§ æ£€æŸ¥ç¼“å­˜ç‰ˆæœ¬å·
        const cacheVersionIndex = resultSet.getColumnIndex('cacheVersion');
        let cacheVersion = 1; // é»˜è®¤ç‰ˆæœ¬1ï¼ˆæ—§æ•°æ®æ²¡æœ‰æ­¤å­—æ®µï¼‰
        if (cacheVersionIndex >= 0) {
          cacheVersion = resultSet.getLong(cacheVersionIndex);
        }
        
        if (cacheVersion < WeatherCacheStorage.CACHE_VERSION) {
          console.warn(`[WeatherCacheStorage] âš ï¸ ç¼“å­˜ç‰ˆæœ¬è¿‡æ—§ (${cacheVersion} < ${WeatherCacheStorage.CACHE_VERSION})ï¼Œæ¸…é™¤æ—§ç¼“å­˜: ${cityId}`);
          await this.clear(cityId);
          return null;
        }
        
        const payload: string = resultSet.getString(resultSet.getColumnIndex('payload'));
        const snapshot = JSON.parse(payload) as WeatherSnapshot;
        console.debug(`[WeatherCacheStorage] âœ… ç¼“å­˜è¯»å–æˆåŠŸ (${cityId}, ç‰ˆæœ¬: ${cacheVersion})ï¼Œè€—æ—¶: ${Date.now() - startTime}ms`);
        return snapshot;
      } catch (error) {
        console.error(`[WeatherCacheStorage] âŒ ç¼“å­˜è§£æå¤±è´¥ (${cityId}), æ¸…é™¤æŸåæ•°æ®:`, error);
        await this.clear(cityId);
        return null;
      } finally {
        resultSet.close();
      }
    } catch (error) {
      console.error(`[WeatherCacheStorage] âŒ ç¼“å­˜æŸ¥è¯¢å¤±è´¥ (${cityId}):`, error);
      return null;
    }
  }

  async clear(cityId: string): Promise<void> {
    if (!this.rdbStore) return;
    console.info(`[WeatherCacheStorage] ğŸ—‘ï¸ æ¸…é™¤ç¼“å­˜: ${cityId}`);
    try {
      const predicates: relationalStore.RdbPredicates = new relationalStore.RdbPredicates(AppConstants.WEATHER_TABLE);
      predicates.equalTo('cityId', cityId);
      await this.rdbStore.delete(predicates);
    } catch (error) {
      console.error(`[WeatherCacheStorage] âŒ æ¸…é™¤ç¼“å­˜å¤±è´¥ (${cityId}):`, error);
    }
  }
}
