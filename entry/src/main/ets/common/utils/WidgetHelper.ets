import { DesignSystem } from '../theme/DesignSystem';
import { ThemeConstants } from '../constants/ThemeConstants';
import type { WeatherSnapshot } from '../../data/models/WeatherModels';
import type { WidgetWeatherData, WidgetHourlyItem } from '../../data/storage/WidgetDataStorage';

/**
 * Gradient color stop type for widget backgrounds
 */
type GradientColorStop = [ResourceColor, number];

/**
 * å¯¼å‡º GradientColorStop ç±»å‹ä¾› Widget ç»„ä»¶ä½¿ç”¨
 */
export type { GradientColorStop };

/**
 * WidgetHelper - Utility class for weather widget operations
 * 
 * Provides helper functions for:
 * - Theme to gradient color mapping
 * - Icon code to Resource mapping
 * - Time formatting
 * - Data staleness detection
 * - WeatherSnapshot to WidgetWeatherData conversion
 * 
 * Requirements: 1.4, 3.4, 5.2, 8.3
 */
export class WidgetHelper {
  /**
   * Staleness threshold in milliseconds (30 minutes)
   */
  private static readonly STALENESS_THRESHOLD_MS: number = 30 * 60 * 1000;

  /**
   * Get gradient colors for widget background based on weather theme
   * Returns a valid gradient color array with at least 2 color stops
   * 
   * @param themeKey Weather theme key (sunny, rainy, snow, sunny_night, rainy_night, snow_night)
   * @returns Array of gradient color stops [color, position]
   * Requirements: 5.2
   */
  static getGradientByTheme(themeKey: string): GradientColorStop[] {
    const theme = ThemeConstants.getTheme(themeKey);
    const gradientColors = theme.gradientColors;
    
    // Ensure we have at least 2 colors for a valid gradient
    if (gradientColors.length >= 2) {
      return [
        [gradientColors[0], 0.0],
        [gradientColors[1], 1.0]
      ];
    }
    
    // Fallback to default sunny gradient if theme has insufficient colors
    return [
      ['#87CEEB', 0.0],
      ['#4A90E2', 1.0]
    ];
  }

  /**
   * è·å–åŸºäºå¤©æ°”ä¸»é¢˜çš„æ¸å˜è‰²ï¼ˆWidget ä¸“ç”¨ç‰ˆæœ¬ï¼‰
   * æä¾›å®Œæ•´çš„ä¸»é¢˜åˆ°æ¸å˜è‰²æ˜ å°„ï¼ŒåŒ…æ‹¬æ—¥å¤œå˜ä½“
   * 
   * @param themeKey å¤©æ°”ä¸»é¢˜é”®ï¼ˆå¦‚ sunny, sunny_day, sunny_night, rainy, snow ç­‰ï¼‰
   * @returns æ¸å˜è‰²æ•°ç»„ï¼Œè‡³å°‘åŒ…å« 2 ä¸ªè‰²æ ‡
   * Requirements: 1.1, 1.3, 1.5
   */
  static getGradientColors(themeKey: string): GradientColorStop[] {
    // ä¸»é¢˜åˆ°æ¸å˜è‰²çš„å®Œæ•´æ˜ å°„è¡¨
    const gradientMap: Record<string, GradientColorStop[]> = {
      'sunny': [['#4A90E2', 0.0], ['#87CEEB', 1.0]],
      'sunny_day': [['#4A90E2', 0.0], ['#87CEEB', 1.0]],
      'sunny_night': [['#1a1a2e', 0.0], ['#16213e', 1.0]],
      'cloudy': [['#546E7A', 0.0], ['#78909C', 1.0]],
      'cloudy_day': [['#546E7A', 0.0], ['#78909C', 1.0]],
      'cloudy_night': [['#2C3E50', 0.0], ['#34495E', 1.0]],
      'rainy': [['#3D5A80', 0.0], ['#5C7A99', 1.0]],
      'rainy_day': [['#3D5A80', 0.0], ['#5C7A99', 1.0]],
      'rainy_night': [['#1B2838', 0.0], ['#2C3E50', 1.0]],
      'snow': [['#E8EEF2', 0.0], ['#B0BEC5', 1.0]],
      'snow_day': [['#E8EEF2', 0.0], ['#B0BEC5', 1.0]],
      'snow_night': [['#37474F', 0.0], ['#455A64', 1.0]],
      'fog': [['#90A4AE', 0.0], ['#B0BEC5', 1.0]],
      'haze': [['#8D6E63', 0.0], ['#A1887F', 1.0]],
      'storm': [['#263238', 0.0], ['#37474F', 1.0]]
    };

    const normalizedKey = themeKey.toLowerCase().trim();
    
    if (gradientMap[normalizedKey]) {
      return gradientMap[normalizedKey];
    }
    
    // å›é€€åˆ°æ™´å¤©æ¸å˜è‰²
    return [['#4A90E2', 0.0], ['#87CEEB', 1.0]];
  }

  /**
   * è·å–å¤©æ°”å›¾æ ‡èµ„æºï¼ˆWidget ä¸“ç”¨ç‰ˆæœ¬ï¼‰
   * ä¸ getIconResource åŠŸèƒ½ç›¸åŒï¼Œæä¾›åˆ«åä»¥ä¿æŒå‘åå…¼å®¹
   * 
   * @param iconCode å¤©æ°”å›¾æ ‡ä»£ç 
   * @returns å¤©æ°”å›¾æ ‡èµ„æº
   * Requirements: 1.1, 1.3, 1.5
   */
  static getWeatherIcon(iconCode: string): Resource {
    return WidgetHelper.getIconResource(iconCode);
  }

  /**
   * Get icon Resource based on weather icon code
   * Falls back to sun icon for unknown codes
   * 
   * @param iconCode Weather icon code string
   * @returns Resource object for the weather icon
   * Requirements: 1.4, 8.3
   */
  static getIconResource(iconCode: string): Resource {
    // Map icon codes to DesignSystem icon resources
    // Icon codes typically follow patterns like: sun, cloudy, rain, snow, etc.
    const iconMap: Record<string, Resource> = {
      'sun': DesignSystem.ICON_SUN,
      'sunny': DesignSystem.ICON_SUN,
      'clear': DesignSystem.ICON_SUN,
      'clear-day': DesignSystem.ICON_SUN,
      'clear-night': DesignSystem.ICON_MOON,
      'moon': DesignSystem.ICON_MOON,
      'cloudy': DesignSystem.ICON_CLOUDY,
      'cloud': DesignSystem.ICON_CLOUDY,
      'partly-cloudy': DesignSystem.ICON_CLOUDY,
      'partly-cloudy-day': DesignSystem.ICON_CLOUDY,
      'partly-cloudy-night': DesignSystem.ICON_CLOUD_MOON,
      'cloud-moon': DesignSystem.ICON_CLOUD_MOON,
      'overcast': DesignSystem.ICON_OVERCAST,
      'rain': DesignSystem.ICON_RAIN,
      'rainy': DesignSystem.ICON_RAIN,
      'drizzle': DesignSystem.ICON_DRIZZLE,
      'light-rain': DesignSystem.ICON_DRIZZLE,
      'heavy-rain': DesignSystem.ICON_RAIN,
      'storm': DesignSystem.ICON_STORM,
      'thunderstorm': DesignSystem.ICON_STORM,
      'snow': DesignSystem.ICON_SNOW,
      'snowy': DesignSystem.ICON_SNOW,
      'light-snow': DesignSystem.ICON_SNOW,
      'heavy-snow': DesignSystem.ICON_SNOW,
      'fog': DesignSystem.ICON_FOG,
      'foggy': DesignSystem.ICON_FOG,
      'mist': DesignSystem.ICON_FOG,
      'haze': DesignSystem.ICON_HAZE,
      'hazy': DesignSystem.ICON_HAZE,
      'wind': DesignSystem.ICON_WIND,
      'windy': DesignSystem.ICON_WIND
    };

    // Normalize icon code to lowercase for matching
    const normalizedCode = iconCode.toLowerCase().trim();
    
    // Try exact match first
    if (iconMap[normalizedCode]) {
      return iconMap[normalizedCode];
    }
    
    // Try partial match for compound codes
    for (const key of Object.keys(iconMap)) {
      if (normalizedCode.includes(key)) {
        return iconMap[key];
      }
    }
    
    // Fallback to sun icon for unknown codes
    console.warn(`[WidgetHelper] Unknown icon code: ${iconCode}, using default sun icon`);
    return DesignSystem.ICON_SUN;
  }


  /**
   * Format timestamp to human-readable update time string
   * 
   * @param timestamp Unix timestamp in milliseconds
   * @returns Formatted time string like "14:30 æ›´æ–°"
   * Requirements: 1.5
   */
  static formatUpdateTime(timestamp: number): string {
    if (!timestamp || timestamp <= 0) {
      return '--:-- æ›´æ–°';
    }
    
    const date = new Date(timestamp);
    const hours = date.getHours();
    const minutes = date.getMinutes();
    
    const hoursStr = hours < 10 ? `0${hours}` : `${hours}`;
    const minutesStr = minutes < 10 ? `0${minutes}` : `${minutes}`;
    
    return `${hoursStr}:${minutesStr} æ›´æ–°`;
  }

  /**
   * Check if weather data is stale (older than 30 minutes)
   * Returns true if and only if the timestamp is more than 30 minutes older than current time
   * 
   * @param timestamp Unix timestamp in milliseconds
   * @returns true if data is stale, false otherwise
   * Requirements: 3.4
   */
  static isDataStale(timestamp: number): boolean {
    if (!timestamp || timestamp <= 0) {
      return true;
    }
    
    const now = Date.now();
    const age = now - timestamp;
    
    return age > WidgetHelper.STALENESS_THRESHOLD_MS;
  }

  /**
   * Convert WeatherSnapshot to WidgetWeatherData
   * Produces an object containing all required fields with non-null values
   * 
   * @param snapshot Weather snapshot from main application
   * @param cityName City name to display
   * @returns WidgetWeatherData object ready for widget display
   * Requirements: 1.1, 1.2, 1.3, 1.5
   */
  static convertToWidgetData(snapshot: WeatherSnapshot, cityName: string): WidgetWeatherData {
    const now = Date.now();
    
    console.info(`[WidgetHelper] ğŸ”„ Converting snapshot to widget data for city: ${cityName}`);
    console.info(`[WidgetHelper] ğŸ“Š Snapshot current - temp: ${snapshot.current.temperatureC}, humidity: ${snapshot.current.humidity}, windSpeed: ${snapshot.current.windSpeedKph}`);
    console.info(`[WidgetHelper] ğŸ“Š Snapshot hourly count: ${snapshot.hourly?.length ?? 0}`);
    
    // Extract hourly forecast (up to 3 items)
    const hourlyForecast: WidgetHourlyItem[] = [];
    const hourlyArray = snapshot.hourly ?? [];
    const hourlyCount = Math.min(hourlyArray.length, 3);
    
    for (let i = 0; i < hourlyCount; i++) {
      const hourly = hourlyArray[i];
      const item: WidgetHourlyItem = {
        time: WidgetHelper.extractTimeFromIso(hourly.time),
        temperature: Math.round(hourly.temperatureC),
        iconCode: hourly.iconCode || 'sun'
      };
      hourlyForecast.push(item);
      console.info(`[WidgetHelper] ğŸ“Š Hourly[${i}]: ${item.time}, ${item.temperature}Â°, ${item.iconCode}`);
    }
    
    // Build widget data with all required fields
    const humidity = snapshot.current.humidity !== undefined && snapshot.current.humidity !== null 
      ? snapshot.current.humidity 
      : 0;
    const windSpeed = snapshot.current.windSpeedKph !== undefined && snapshot.current.windSpeedKph !== null 
      ? Math.round(snapshot.current.windSpeedKph) 
      : 0;
    
    const widgetData: WidgetWeatherData = {
      cityName: cityName || 'æœªçŸ¥åŸå¸‚',
      temperature: Math.round(snapshot.current.temperatureC),
      temperatureUnit: 'Â°C',
      condition: snapshot.current.condition.description || 'æœªçŸ¥',
      iconCode: snapshot.current.condition.iconCode || 'sun',
      themeKey: snapshot.current.condition.themeKey || 'sunny',
      humidity: humidity,
      windSpeed: windSpeed,
      updateTime: WidgetHelper.formatUpdateTime(now),
      timestamp: now,
      hourlyForecast: hourlyForecast
    };
    
    console.info(`[WidgetHelper] âœ… Widget data created - humidity: ${widgetData.humidity}%, windSpeed: ${widgetData.windSpeed} km/h, hourly: ${widgetData.hourlyForecast.length}`);
    
    return widgetData;
  }

  /**
   * Extract time string (HH:mm) from ISO date string
   * 
   * @param isoString ISO format date string
   * @returns Time string like "14:00"
   */
  private static extractTimeFromIso(isoString: string): string {
    if (!isoString) {
      return '--:--';
    }
    
    try {
      const date = new Date(isoString);
      const hours = date.getHours();
      const minutes = date.getMinutes();
      
      const hoursStr = hours < 10 ? `0${hours}` : `${hours}`;
      const minutesStr = minutes < 10 ? `0${minutes}` : `${minutes}`;
      
      return `${hoursStr}:${minutesStr}`;
    } catch (error) {
      console.error('[WidgetHelper] Failed to parse ISO time:', error);
      return '--:--';
    }
  }

  /**
   * Get default widget data for fallback scenarios
   * Used when no cached data is available
   * 
   * @returns Default WidgetWeatherData with placeholder values
   * Requirements: 8.1, 8.2
   */
  static getDefaultWidgetData(): WidgetWeatherData {
    return {
      cityName: 'ç‚¹å‡»åˆ·æ–°',
      temperature: 0,
      temperatureUnit: 'Â°C',
      condition: 'æ•°æ®åŠ è½½ä¸­',
      iconCode: 'sun',
      themeKey: 'sunny',
      humidity: 0,
      windSpeed: 0,
      updateTime: '--:-- æ›´æ–°',
      timestamp: 0,
      hourlyForecast: []
    };
  }
}
