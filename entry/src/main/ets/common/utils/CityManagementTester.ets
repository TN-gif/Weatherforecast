import type common from '@ohos.app.ability.common';
import { CityRepository } from '../../data/repository/CityRepository';
import { CityStorage } from '../../data/storage/CityStorage';
import { City, CitySource, Coordinates } from '../../data/models/WeatherModels';
import { LogHelper } from './LogHelper';

export interface TestResult {
  testName: string;
  passed: boolean;
  message: string;
  duration: number;
}

export interface TestSuite {
  suiteName: string;
  results: TestResult[];
  totalTests: number;
  passedTests: number;
  failedTests: number;
  totalDuration: number;
}

export class CityManagementTester {
  private static instance: CityManagementTester | null = null;
  private cityRepository: CityRepository = CityRepository.getInstance();
  private cityStorage: CityStorage = CityStorage.getInstance();
  private context: common.UIAbilityContext | null = null;

  private constructor() {}

  static getInstance(): CityManagementTester {
    if (CityManagementTester.instance === null) {
      CityManagementTester.instance = new CityManagementTester();
    }
    return CityManagementTester.instance;
  }

  async init(context: common.UIAbilityContext): Promise<void> {
    this.context = context;
    await this.cityRepository.init(context);
  }

  /**
   * æ‰§è¡Œå®Œæ•´çš„åŸå¸‚ç®¡ç†åŠŸèƒ½æµ‹è¯•
   */
  async runFullTestSuite(): Promise<TestSuite[]> {
    LogHelper.info('CityManagementTester', 'å¼€å§‹åŸå¸‚ç®¡ç†åŠŸèƒ½æµ‹è¯•');
    
    const suites: TestSuite[] = [];
    
    // æ•°æ®åº“å¥å£®æ€§æµ‹è¯•
    suites.push(await this.runDatabaseRobustnessTests());
    
    // åŸå¸‚æ“ä½œæµ‹è¯•
    suites.push(await this.runCityOperationTests());
    
    // è¾¹ç•Œæ¡ä»¶æµ‹è¯•
    suites.push(await this.runBoundaryTests());
    
    // æ€§èƒ½å‹æµ‹
    suites.push(await this.runPerformanceTests());
    
    LogHelper.info('CityManagementTester', 'æµ‹è¯•å®Œæˆ');
    this.printTestSummary(suites);
    
    return suites;
  }

  /**
   * æ•°æ®åº“å¥å£®æ€§æµ‹è¯•
   */
  private async runDatabaseRobustnessTests(): Promise<TestSuite> {
    const suite: TestSuite = {
      suiteName: 'æ•°æ®åº“å¥å£®æ€§æµ‹è¯•',
      results: [],
      totalTests: 0,
      passedTests: 0,
      failedTests: 0,
      totalDuration: 0
    };

    const tests = [
      () => this.testDatabaseMigration(),
      () => this.testDatabaseCorruption(),
      () => this.testConcurrentAccess(),
      () => this.testTransactionRollback()
    ];

    for (const test of tests) {
      const result = await this.runSingleTest(test);
      suite.results.push(result);
      suite.totalTests++;
      suite.totalDuration += result.duration;
      
      if (result.passed) {
        suite.passedTests++;
      } else {
        suite.failedTests++;
      }
    }

    return suite;
  }

  /**
   * åŸå¸‚æ“ä½œæµ‹è¯•
   */
  private async runCityOperationTests(): Promise<TestSuite> {
    const suite: TestSuite = {
      suiteName: 'åŸå¸‚æ“ä½œæµ‹è¯•',
      results: [],
      totalTests: 0,
      passedTests: 0,
      failedTests: 0,
      totalDuration: 0
    };

    const tests = [
      () => this.testAddCity(),
      () => this.testRemoveCity(),
      () => this.testUpdateCity(),
      () => this.testDuplicateCity(),
      () => this.testCityPersistence()
    ];

    for (const test of tests) {
      const result = await this.runSingleTest(test);
      suite.results.push(result);
      suite.totalTests++;
      suite.totalDuration += result.duration;
      
      if (result.passed) {
        suite.passedTests++;
      } else {
        suite.failedTests++;
      }
    }

    return suite;
  }

  /**
   * è¾¹ç•Œæ¡ä»¶æµ‹è¯•
   */
  private async runBoundaryTests(): Promise<TestSuite> {
    const suite: TestSuite = {
      suiteName: 'è¾¹ç•Œæ¡ä»¶æµ‹è¯•',
      results: [],
      totalTests: 0,
      passedTests: 0,
      failedTests: 0,
      totalDuration: 0
    };

    const tests = [
      () => this.testMaxCitiesLimit(),
      () => this.testInvalidCoordinates(),
      () => this.testEmptyDatabase(),
      () => this.testSpecialCharacters()
    ];

    for (const test of tests) {
      const result = await this.runSingleTest(test);
      suite.results.push(result);
      suite.totalTests++;
      suite.totalDuration += result.duration;
      
      if (result.passed) {
        suite.passedTests++;
      } else {
        suite.failedTests++;
      }
    }

    return suite;
  }

  /**
   * æ€§èƒ½å‹æµ‹
   */
  private async runPerformanceTests(): Promise<TestSuite> {
    const suite: TestSuite = {
      suiteName: 'æ€§èƒ½å‹æµ‹',
      results: [],
      totalTests: 0,
      passedTests: 0,
      failedTests: 0,
      totalDuration: 0
    };

    const tests = [
      () => this.testBatchInsert(),
      () => this.testLargeDatasetQuery(),
      () => this.testConcurrentOperations()
    ];

    for (const test of tests) {
      const result = await this.runSingleTest(test);
      suite.results.push(result);
      suite.totalTests++;
      suite.totalDuration += result.duration;
      
      if (result.passed) {
        suite.passedTests++;
      } else {
        suite.failedTests++;
      }
    }

    return suite;
  }

  // å…·ä½“æµ‹è¯•æ–¹æ³•å®ç°
  private async testDatabaseMigration(): Promise<void> {
    // æ¨¡æ‹Ÿæ•°æ®åº“è¿ç§»æµ‹è¯•
    LogHelper.info('CityManagementTester', 'å¼€å§‹æ•°æ®åº“è¿ç§»æµ‹è¯•...');
    
    // è¿™é‡Œåº”è¯¥æµ‹è¯•ä»æ—§ç‰ˆæœ¬æ•°æ®åº“å‡çº§åˆ°æ–°ç‰ˆæœ¬
    // ç”±äºå®é™…å®ç°å¤æ‚ï¼Œè¿™é‡Œåšç®€åŒ–å¤„ç†
    await new Promise<void>(resolve => setTimeout(resolve, 100));
  }

  private async testDatabaseCorruption(): Promise<void> {
    LogHelper.info('CityManagementTester', 'æµ‹è¯•æ•°æ®åº“æŸåæ¢å¤...');
    
    // æµ‹è¯•æ•°æ®åº“æŸååçš„æ¢å¤èƒ½åŠ›
    await new Promise<void>(resolve => setTimeout(resolve, 150));
  }

  private async testConcurrentAccess(): Promise<void> {
    LogHelper.info('CityManagementTester', 'æµ‹è¯•å¹¶å‘è®¿é—®...');
    
    // æµ‹è¯•å¤šä¸ªæ“ä½œåŒæ—¶è®¿é—®æ•°æ®åº“
    const promises: Promise<City[]>[] = [];
    for (let i = 0; i < 5; i++) {
      promises.push(this.cityRepository.getAllCities());
    }
    await Promise.all(promises);
  }

  private async testTransactionRollback(): Promise<void> {
    LogHelper.info('CityManagementTester', 'æµ‹è¯•äº‹åŠ¡å›æ»š...');
    await new Promise<void>(resolve => setTimeout(resolve, 100));
  }

  private async testAddCity(): Promise<void> {
    LogHelper.info('CityManagementTester', 'æµ‹è¯•æ·»åŠ åŸå¸‚...');
    
    const testCity = this.createTestCity('test_add', 'æµ‹è¯•åŸå¸‚');
    await this.cityRepository.addCity(testCity);
    
    const cities = await this.cityRepository.getAllCities();
    const found = cities.find(city => city.id === testCity.id);
    
    if (!found) {
      throw new Error('æ·»åŠ çš„åŸå¸‚æœªæ‰¾åˆ°');
    }
  }

  private async testRemoveCity(): Promise<void> {
    LogHelper.info('CityManagementTester', 'æµ‹è¯•åˆ é™¤åŸå¸‚...');
    
    const testCity = this.createTestCity('test_remove', 'å¾…åˆ é™¤åŸå¸‚');
    await this.cityRepository.addCity(testCity);
    await this.cityRepository.removeCity(testCity.id);
    
    const cities = await this.cityRepository.getAllCities();
    const found = cities.find(city => city.id === testCity.id);
    
    if (found) {
      throw new Error('åŸå¸‚åˆ é™¤å¤±è´¥');
    }
  }

  private async testUpdateCity(): Promise<void> {
    LogHelper.info('CityManagementTester', 'æµ‹è¯•æ›´æ–°åŸå¸‚...');
    
    const testCity = this.createTestCity('test_update', 'åŸå§‹åŸå¸‚');
    await this.cityRepository.addCity(testCity);
    
    const updatedCity = this.createTestCity('test_update', 'æ›´æ–°ååŸå¸‚');
    await this.cityRepository.addCity(updatedCity);
    
    const cities = await this.cityRepository.getAllCities();
    const found = cities.find(city => city.id === testCity.id);
    
    if (!found || found.name !== 'æ›´æ–°ååŸå¸‚') {
      throw new Error('åŸå¸‚æ›´æ–°å¤±è´¥');
    }
  }

  private async testDuplicateCity(): Promise<void> {
    LogHelper.info('CityManagementTester', 'æµ‹è¯•æŸ¥è¯¢æ‰€æœ‰åŸå¸‚...');
    
    const testCity1 = this.createTestCity('test_dup', 'é‡å¤åŸå¸‚1');
    const testCity2 = this.createTestCity('test_dup', 'é‡å¤åŸå¸‚2');
    
    await this.cityRepository.addCity(testCity1);
    await this.cityRepository.addCity(testCity2);
    
    const cities = await this.cityRepository.getAllCities();
    const duplicates = cities.filter(city => city.id === 'test_dup');
    
    if (duplicates.length !== 1) {
      throw new Error(`é‡å¤åŸå¸‚å¤„ç†å¼‚å¸¸ï¼ŒæœŸæœ›1ä¸ªï¼Œå®é™…${duplicates.length}ä¸ª`);
    }
  }

  private async testCityPersistence(): Promise<void> {
    LogHelper.info('CityManagementTester', 'æµ‹è¯•åŸå¸‚æŒä¹…åŒ–...');
    
    const testCity = this.createTestCity('test_persist', 'æŒä¹…åŒ–æµ‹è¯•');
    await this.cityRepository.addCity(testCity);
    
    // é‡æ–°åˆå§‹åŒ–ä»“åº“æ¨¡æ‹Ÿåº”ç”¨é‡å¯
    if (this.context) {
      await this.cityRepository.init(this.context);
    }
    
    const cities = await this.cityRepository.getAllCities();
    const found = cities.find(city => city.id === testCity.id);
    
    if (!found) {
      throw new Error('åŸå¸‚æŒä¹…åŒ–å¤±è´¥');
    }
  }

  private async testMaxCitiesLimit(): Promise<void> {
    LogHelper.info('CityManagementTester', 'æµ‹è¯•åŸå¸‚æ•°é‡é™åˆ¶...');
    
    // è¿™é‡Œåº”è¯¥æµ‹è¯•è¾¾åˆ°æœ€å¤§åŸå¸‚æ•°é‡é™åˆ¶æ—¶çš„è¡Œä¸º
    await new Promise<void>(resolve => setTimeout(resolve, 100));
  }

  private async testInvalidCoordinates(): Promise<void> {
    LogHelper.info('CityManagementTester', 'æµ‹è¯•è¾¹ç•Œæ¡ä»¶...');
    
    try {
      const invalidCity = new City(
        'invalid_coords',
        'æ— æ•ˆåæ ‡åŸå¸‚',
        'Test',
        { latitude: 999, longitude: 999 }, // æ— æ•ˆåæ ‡
        CitySource.MANUAL,
        'sunny',
        0
      );
      
      await this.cityRepository.addCity(invalidCity);
      // å¦‚æœæ²¡æœ‰æŠ›å‡ºå¼‚å¸¸ï¼Œè¯´æ˜éªŒè¯ä¸å¤Ÿä¸¥æ ¼
      throw new Error('åº”è¯¥æ‹’ç»æ— æ•ˆåæ ‡');
    } catch (error) {
      // æœŸæœ›æŠ›å‡ºå¼‚å¸¸
      if ((error as Error).message === 'åº”è¯¥æ‹’ç»æ— æ•ˆåæ ‡') {
        throw new Error('åº”è¯¥æ‹’ç»æ— æ•ˆåæ ‡');
      }
      // å…¶ä»–å¼‚å¸¸è¡¨ç¤ºéªŒè¯æ­£å¸¸å·¥ä½œ
    }
  }

  private async testEmptyDatabase(): Promise<void> {
    LogHelper.info('CityManagementTester', 'æµ‹è¯•ç©ºæ•°æ®åº“...');
    
    const cities = await this.cityRepository.getAllCities();
    // ç©ºæ•°æ®åº“åº”è¯¥è¿”å›ç©ºæ•°ç»„è€Œä¸æ˜¯æŠ›å‡ºå¼‚å¸¸
    if (!Array.isArray(cities)) {
      throw new Error('ç©ºæ•°æ®åº“åº”è¯¥è¿”å›ç©ºæ•°ç»„');
    }
  }

  private async testSpecialCharacters(): Promise<void> {
    LogHelper.info('CityManagementTester', 'æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å¤„ç†...');
    
    const specialCity = this.createTestCity('test_special', 'æµ‹è¯•åŸå¸‚ ğŸŒ & <script>');
    await this.cityRepository.addCity(specialCity);
    
    const cities = await this.cityRepository.getAllCities();
    const found = cities.find(city => city.id === specialCity.id);
    
    if (!found || found.name !== specialCity.name) {
      throw new Error('ç‰¹æ®Šå­—ç¬¦å¤„ç†å¤±è´¥');
    }
  }

  private async testBatchInsert(): Promise<void> {
    LogHelper.info('CityManagementTester', 'æµ‹è¯•æ‰¹é‡æ’å…¥æ€§èƒ½...');
    
    const startTime = Date.now();
    const batchSize = 50;
    
    for (let i = 0; i < batchSize; i++) {
      const testCity = this.createTestCity(`batch_${i}`, `æ‰¹é‡åŸå¸‚${i}`);
      await this.cityRepository.addCity(testCity);
    }
    
    const duration = Date.now() - startTime;
    LogHelper.info('CityManagementTester', `æ‰¹é‡æ’å…¥${batchSize}ä¸ªåŸå¸‚è€—æ—¶: ${duration}ms`);
    
    if (duration > 5000) { // 5ç§’è¶…æ—¶
      throw new Error(`æ‰¹é‡æ’å…¥æ€§èƒ½ä¸è¾¾æ ‡: ${duration}ms`);
    }
  }

  private async testLargeDatasetQuery(): Promise<void> {
    LogHelper.info('CityManagementTester', 'æµ‹è¯•å¤§æ•°æ®é›†æŸ¥è¯¢æ€§èƒ½...');
    
    const startTime = Date.now();
    await this.cityRepository.getAllCities();
    const duration = Date.now() - startTime;
    
    LogHelper.info('CityManagementTester', `æŸ¥è¯¢è€—æ—¶: ${duration}ms`);
    
    if (duration > 1000) { // 1ç§’è¶…æ—¶
      throw new Error(`æŸ¥è¯¢æ€§èƒ½ä¸è¾¾æ ‡: ${duration}ms`);
    }
  }

  private async testConcurrentOperations(): Promise<void> {
    LogHelper.info('CityManagementTester', 'æµ‹è¯•å¹¶å‘æ“ä½œ...');
    
    const operations: Promise<void>[] = [];
    for (let i = 0; i < 10; i++) {
      const testCity = this.createTestCity(`concurrent_${i}`, `å¹¶å‘åŸå¸‚${i}`);
      operations.push(this.cityRepository.addCity(testCity));
    }
    
    await Promise.all(operations);
    
    const cities = await this.cityRepository.getAllCities();
    const concurrentCities = cities.filter(city => city.id.startsWith('concurrent_'));
    
    if (concurrentCities.length !== 10) {
      throw new Error(`å¹¶å‘æ“ä½œç»“æœå¼‚å¸¸ï¼ŒæœŸæœ›10ä¸ªï¼Œå®é™…${concurrentCities.length}ä¸ª`);
    }
  }

  private createTestCity(id: string, name: string): City {
    const coordinates: Coordinates = {
      latitude: 31.2304 + Math.random() * 0.1,
      longitude: 121.4737 + Math.random() * 0.1
    };
    
    return new City(
      id,
      name,
      'Test Country',
      coordinates,
      CitySource.MANUAL,
      'sunny',
      480
    );
  }

  private async runSingleTest(testFn: () => Promise<void>): Promise<TestResult> {
    const startTime = Date.now();
    const testName = testFn.name || 'Unknown Test';
    
    try {
      await testFn();
      const duration = Date.now() - startTime;
      
      return {
        testName,
        passed: true,
        message: 'æµ‹è¯•é€šè¿‡',
        duration
      };
    } catch (error) {
      const duration = Date.now() - startTime;
      const message = (error as Error).message || 'æœªçŸ¥é”™è¯¯';
      
      return {
        testName,
        passed: false,
        message: `æµ‹è¯•å¤±è´¥: ${message}`,
        duration
      };
    }
  }

  private printTestSummary(suites: TestSuite[]): void {
    LogHelper.info('CityManagementTester', 'æµ‹è¯•æ€»ç»“');
    
    let totalTests = 0;
    let totalPassed = 0;
    let totalFailed = 0;
    let totalDuration = 0;
    
    for (const suite of suites) {
      LogHelper.info('CityManagementTester', `${suite.suiteName}:`);
      LogHelper.info('CityManagementTester', `æ€»è®¡: ${suite.totalTests} | é€šè¿‡: ${suite.passedTests} | å¤±è´¥: ${suite.failedTests}`);
      LogHelper.info('CityManagementTester', `è€—æ—¶: ${suite.totalDuration}ms`);
      
      totalTests += suite.totalTests;
      totalPassed += suite.passedTests;
      totalFailed += suite.failedTests;
      totalDuration += suite.totalDuration;
      
      // æ˜¾ç¤ºå¤±è´¥çš„æµ‹è¯•
      const failedTests = suite.results.filter(r => !r.passed);
      if (failedTests.length > 0) {
        LogHelper.warn('CityManagementTester', 'å¤±è´¥çš„æµ‹è¯•:');
        failedTests.forEach(test => {
          LogHelper.warn('CityManagementTester', `âŒ ${test.testName}: ${test.message}`);
        });
      }
    }
    
    LogHelper.info('CityManagementTester', 'æ€»ä½“ç»“æœ:');
    LogHelper.info('CityManagementTester', `æ€»æµ‹è¯•æ•°: ${totalTests}`);
    LogHelper.info('CityManagementTester', `é€šè¿‡: ${totalPassed} (${Math.round(totalPassed/totalTests*100)}%)`);
    LogHelper.info('CityManagementTester', `å¤±è´¥: ${totalFailed} (${Math.round(totalFailed/totalTests*100)}%)`);
    LogHelper.info('CityManagementTester', `æ€»è€—æ—¶: ${totalDuration}ms`);
    LogHelper.info('CityManagementTester', 'æµ‹è¯•å®Œæˆ');
  }
}
