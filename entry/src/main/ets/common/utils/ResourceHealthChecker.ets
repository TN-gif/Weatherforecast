import resourceManager from '@ohos.resourceManager';
import { ThemeConstants, VideoThemeAsset, BackgroundMode } from '../constants/ThemeConstants';
import { LogHelper } from './LogHelper';

export interface ResourceCheckResult {
  themeKey: string;
  videoExists: boolean;
  animatedImageExists: boolean;
  lottieExists: boolean;
  isHealthy: boolean;
  missingResources: string[];
}

export interface ResourceHealthReport {
  totalThemes: number;
  healthyThemes: number;
  unhealthyThemes: number;
  results: ResourceCheckResult[];
  overallHealth: number; // 0-100 percentage
}

export class ResourceHealthChecker {
  private static instance: ResourceHealthChecker | null = null;
  private resourceManager: resourceManager.ResourceManager | null = null;
  private lastReport: ResourceHealthReport | null = null;

  private constructor() {}

  static getInstance(): ResourceHealthChecker {
    if (ResourceHealthChecker.instance === null) {
      ResourceHealthChecker.instance = new ResourceHealthChecker();
    }
    return ResourceHealthChecker.instance;
  }

  async init(resMgr: resourceManager.ResourceManager): Promise<void> {
    this.resourceManager = resMgr;
    LogHelper.info('ResourceHealthChecker', 'Initialized with resource manager');
  }

  async detect(): Promise<void> {
    this.lastReport = await this.performFullHealthCheck();
  }

  getRecommendedBackgroundMode(): BackgroundMode {
    if (!this.lastReport) {
      return BackgroundMode.GRADIENT;
    }
    // å¦‚æœå¥åº·åº¦å¤§äº 50%ï¼Œæ¨è VIDEO æ¨¡å¼ï¼ˆå¦‚æœæ”¯æŒï¼‰ï¼Œå¦åˆ™ GRADIENT
    // è¿™é‡Œç®€å•è¿”å› VIDEOï¼Œå®é™…é€»è¾‘å¯ä»¥åœ¨ AtmosphereBackground ä¸­è¿›ä¸€æ­¥åˆ¤æ–­
    return this.lastReport.overallHealth > 50 ? BackgroundMode.VIDEO : BackgroundMode.GRADIENT;
  }

  /**
   * æ‰§è¡Œå®Œæ•´çš„èµ„æºå¥åº·æ£€æŸ¥
   */
  async performFullHealthCheck(): Promise<ResourceHealthReport> {
    LogHelper.info('ResourceHealthChecker', 'å¼€å§‹å…¨é¢èµ„æºå¥åº·æ£€æŸ¥...');
    
    if (!this.resourceManager) {
      throw new Error('ResourceManager not initialized');
    }

    const themes = ThemeConstants.THEMES;
    const results: ResourceCheckResult[] = [];

    for (const theme of themes) {
      LogHelper.info('ResourceHealthChecker', `æ£€æŸ¥ä¸»é¢˜: ${theme.themeKey}`);
      const result = await this.checkThemeResources(theme);
      results.push(result);
      
      if (result.isHealthy) {
        LogHelper.info('ResourceHealthChecker', `âœ… ${theme.themeKey} å¥åº·`);
      } else {
        LogHelper.warn('ResourceHealthChecker', `âŒ ${theme.themeKey} ç¼ºå¤±èµ„æº: ${result.missingResources.join(', ')}`);
      }
    }

    const healthyCount = results.filter(r => r.isHealthy).length;
    const overallHealth = Math.round((healthyCount / results.length) * 100);

    const report: ResourceHealthReport = {
      totalThemes: results.length,
      healthyThemes: healthyCount,
      unhealthyThemes: results.length - healthyCount,
      results: results,
      overallHealth: overallHealth
    };

    LogHelper.info('ResourceHealthChecker', `æ£€æŸ¥å®Œæˆ: ${overallHealth}% å¥åº·`);
    return report;
  }

  /**
   * æ£€æŸ¥å•ä¸ªä¸»é¢˜çš„èµ„æº
   */
  private async checkThemeResources(theme: VideoThemeAsset): Promise<ResourceCheckResult> {
    const missingResources: string[] = [];
    
    // æ£€æŸ¥è§†é¢‘èµ„æº
    const videoExists = theme.videoResource ? await this.checkRawFileExists(theme.videoResource) : true;
    if (theme.videoResource && !videoExists) {
      LogHelper.warn('ResourceHealthChecker', `è§†é¢‘èµ„æºä¸å­˜åœ¨: ${theme.videoResource}`);
      missingResources.push(`video: ${theme.videoResource}`);
    }

    // æ£€æŸ¥WebPåŠ¨ç”»èµ„æº
    const animatedImageExists = theme.animatedImageResource ? await this.checkRawFileExists(theme.animatedImageResource) : true;
    if (theme.animatedImageResource && !animatedImageExists) {
      LogHelper.warn('ResourceHealthChecker', `WebPåŠ¨ç”»èµ„æºä¸å­˜åœ¨: ${theme.animatedImageResource}`);
      missingResources.push(`webp: ${theme.animatedImageResource}`);
    }

    // æ£€æŸ¥Lottieèµ„æº
    const lottieExists = theme.lottieResource ? await this.checkRawFileExists(theme.lottieResource) : true;
    if (theme.lottieResource && !lottieExists) {
      LogHelper.warn('ResourceHealthChecker', `LottieåŠ¨ç”»èµ„æºä¸å­˜åœ¨: ${theme.lottieResource}`);
      missingResources.push(`lottie: ${theme.lottieResource}`);
    }

    const isHealthy = missingResources.length === 0;

    return {
      themeKey: theme.themeKey,
      videoExists,
      animatedImageExists,
      lottieExists,
      isHealthy,
      missingResources
    };
  }

  /**
   * æ£€æŸ¥rawfileèµ„æºæ˜¯å¦å­˜åœ¨
   */
  private async checkRawFileExists(resourcePath: string): Promise<boolean> {
    if (!this.resourceManager) {
      return false;
    }

    try {
      // ç§»é™¤rawfile/å‰ç¼€ï¼Œå› ä¸ºgetRawFileDescriptorä¸éœ€è¦è¿™ä¸ªå‰ç¼€
      const cleanPath = resourcePath.replace(/^rawfile\//, '');
      const descriptor = await this.resourceManager.getRawFileDescriptor(cleanPath);
      
      if (descriptor && descriptor.fd >= 0) {
        // å…³é—­æ–‡ä»¶æè¿°ç¬¦
        try {
          await this.resourceManager.closeRawFileDescriptor(cleanPath);
        } catch (closeError) {
          LogHelper.warn('ResourceHealthChecker', `Failed to close descriptor for ${cleanPath}`);
        }
        return true;
      }
      return false;
    } catch (error) {
      LogHelper.debug('ResourceHealthChecker', `Resource not found: ${resourcePath}`);
      return false;
    }
  }

  /**
   * è·å–ç¼ºå¤±èµ„æºçš„å»ºè®®
   */
  getSuggestions(report: ResourceHealthReport): string[] {
    const suggestions: string[] = [];

    if (report.overallHealth < 50) {
      suggestions.push('âš ï¸ èµ„æºå¥åº·åº¦è¿‡ä½ï¼Œå»ºè®®ç«‹å³è¡¥å……ç¼ºå¤±çš„è§†é¢‘å’ŒåŠ¨ç”»æ–‡ä»¶');
    }

    const missingVideos = report.results.filter(r => !r.videoExists && r.missingResources.some(m => m.includes('video')));
    if (missingVideos.length > 0) {
      suggestions.push(`ğŸ“¹ ç¼ºå¤± ${missingVideos.length} ä¸ªè§†é¢‘æ–‡ä»¶ï¼Œå°†è‡ªåŠ¨é™çº§åˆ°WebPåŠ¨ç”»`);
    }

    const missingWebP = report.results.filter(r => !r.animatedImageExists && r.missingResources.some(m => m.includes('webp')));
    if (missingWebP.length > 0) {
      suggestions.push(`ğŸ–¼ï¸ ç¼ºå¤± ${missingWebP.length} ä¸ªWebPåŠ¨ç”»ï¼Œå°†é™çº§åˆ°é™æ€æ¸å˜èƒŒæ™¯`);
    }

    const missingLottie = report.results.filter(r => !r.lottieExists && r.missingResources.some(m => m.includes('lottie')));
    if (missingLottie.length > 0) {
      suggestions.push(`âœ¨ ç¼ºå¤± ${missingLottie.length} ä¸ªLottieåŠ¨ç”»ï¼Œç•Œé¢è£…é¥°æ•ˆæœå°†å—å½±å“`);
    }

    if (suggestions.length === 0) {
      suggestions.push('âœ… æ‰€æœ‰èµ„æºå®Œæ•´ï¼Œå¯ä»¥äº«å—å®Œæ•´çš„æ²‰æµ¸å¼ä½“éªŒ');
    }

    return suggestions;
  }

  /**
   * ç”Ÿæˆèµ„æºçŠ¶æ€æŠ¥å‘Š
   */
  generateReport(report: ResourceHealthReport): string {
    const lines: string[] = [];
    lines.push('=== èµ„æºå¥åº·æ£€æŸ¥æŠ¥å‘Š ===');
    lines.push(`æ€»ä½“å¥åº·åº¦: ${report.overallHealth}%`);
    lines.push(`å¥åº·ä¸»é¢˜: ${report.healthyThemes}/${report.totalThemes}`);
    lines.push('');

    for (const result of report.results) {
      const status = result.isHealthy ? 'âœ…' : 'âŒ';
      lines.push(`${status} ${result.themeKey}`);
      
      if (!result.isHealthy) {
        result.missingResources.forEach(missing => {
          lines.push(`   - ç¼ºå¤±: ${missing}`);
        });
      }
    }

    lines.push('');
    lines.push('=== å»ºè®® ===');
    this.getSuggestions(report).forEach(suggestion => {
      lines.push(suggestion);
    });

    return lines.join('\n');
  }
}
