/**
 * æ—¥å¿—è¾…åŠ©å·¥å…·ç±»
 * ç”¨äºç»Ÿä¸€ç®¡ç†åº”ç”¨æ—¥å¿—è¾“å‡ºå’Œé—®é¢˜è¯Šæ–­
 */
enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3
}

interface LogLevelMap {
  DEBUG: number;
  INFO: number;
  WARN: number;
  ERROR: number;
}

export class LogHelper {
  private static readonly LOG_LEVELS: LogLevelMap = {
    DEBUG: LogLevel.DEBUG,
    INFO: LogLevel.INFO,
    WARN: LogLevel.WARN,
    ERROR: LogLevel.ERROR
  };

  private static currentLevel = LogLevel.DEBUG;

  /**
   * è®¾ç½®æ—¥å¿—çº§åˆ«
   */
  static setLogLevel(level: 'DEBUG' | 'INFO' | 'WARN' | 'ERROR'): void {
    switch (level) {
      case 'DEBUG':
        LogHelper.currentLevel = LogLevel.DEBUG;
        break;
      case 'INFO':
        LogHelper.currentLevel = LogLevel.INFO;
        break;
      case 'WARN':
        LogHelper.currentLevel = LogLevel.WARN;
        break;
      case 'ERROR':
        LogHelper.currentLevel = LogLevel.ERROR;
        break;
    }
  }

  /**
   * è¾“å‡ºè°ƒè¯•ä¿¡æ¯
   */
  static debug(tag: string, message: string, data?: string): void {
    if (LogHelper.currentLevel <= LogLevel.DEBUG) {
      const timestamp = new Date().toISOString();
      const dataStr = data ? (typeof data === 'string' ? data : JSON.stringify(data)) : '';
      console.debug(`[${timestamp}] [DEBUG] [${tag}] ${message}`, dataStr);
    }
  }

  /**
   * è¾“å‡ºä¿¡æ¯
   */
  static info(tag: string, message: string, data?: string): void {
    if (LogHelper.currentLevel <= LogLevel.INFO) {
      const timestamp = new Date().toISOString();
      const dataStr = data ? (typeof data === 'string' ? data : JSON.stringify(data)) : '';
      console.info(`[${timestamp}] [INFO] [${tag}] ${message}`, dataStr);
    }
  }

  /**
   * è¾“å‡ºè­¦å‘Š
   */
  static warn(tag: string, message: string, data?: string): void {
    if (LogHelper.currentLevel <= LogLevel.WARN) {
      const timestamp = new Date().toISOString();
      const dataStr = data ? (typeof data === 'string' ? data : JSON.stringify(data)) : '';
      console.warn(`[${timestamp}] [WARN] [${tag}] ${message}`, dataStr);
    }
  }

  /**
   * è¾“å‡ºé”™è¯¯
   */
  static error(tag: string, message: string, error?: string | Error): void {
    if (LogHelper.currentLevel <= LogLevel.ERROR) {
      const timestamp = new Date().toISOString();
      console.error(`[${timestamp}] [ERROR] [${tag}] ${message}`);
      if (error) {
        if (error instanceof Error) {
          console.error(`[${timestamp}] [ERROR] [${tag}] Stack: ${error.stack}`);
        } else {
          const errorStr = typeof error === 'string' ? error : JSON.stringify(error);
          console.error(`[${timestamp}] [ERROR] [${tag}] Data: ${errorStr}`);
        }
      }
    }
  }

  /**
   * è¾“å‡ºæ€§èƒ½ç»Ÿè®¡
   */
  static performance(tag: string, operation: string, startTime: number, endTime?: number): void {
    const actualEndTime = endTime || Date.now();
    const duration = actualEndTime - startTime;
    LogHelper.info(tag, `â±ï¸ ${operation} è€—æ—¶: ${duration}ms`);
  }

  /**
   * è¾“å‡ºç½‘ç»œè¯·æ±‚æ—¥å¿—
   */
  static network(tag: string, method: string, url: string, status?: number, duration?: number): void {
    const statusText = status ? `[${status}]` : '[PENDING]';
    const durationText = duration ? ` (${duration}ms)` : '';
    LogHelper.info(tag, `ğŸŒ ${method} ${url} ${statusText}${durationText}`);
  }

  /**
   * è¾“å‡ºæ•°æ®æµæ—¥å¿—
   */
  static dataFlow(tag: string, source: string, target: string, dataType: string, success: boolean = true): void {
    const status = success ? 'âœ…' : 'âŒ';
    LogHelper.info(tag, `ğŸ“Š ${status} ${dataType}: ${source} â†’ ${target}`);
  }

  /**
   * è¾“å‡ºç³»ç»ŸçŠ¶æ€
   */
  static systemStatus(tag: string, component: string, status: 'INIT' | 'READY' | 'ERROR' | 'LOADING'): void {
    const statusEmoji: Record<string, string> = {
      'INIT': 'ğŸ”§',
      'READY': 'âœ…',
      'ERROR': 'âŒ',
      'LOADING': 'â³'
    };
    LogHelper.info(tag, `${statusEmoji[status]} ${component}: ${status}`);
  }

  /**
   * åˆ›å»ºé—®é¢˜è¯Šæ–­æŠ¥å‘Š
   */
  static createDiagnosticReport(): string {
    const timestamp = new Date().toISOString();
    return `
========== å¤©æ°”åº”ç”¨è¯Šæ–­æŠ¥å‘Š ==========
ç”Ÿæˆæ—¶é—´: ${timestamp}
åº”ç”¨ç‰ˆæœ¬: 1.0.0
å¹³å°: HarmonyOS
æ—¥å¿—çº§åˆ«: ${Object.keys(LogHelper.LOG_LEVELS)[LogHelper.currentLevel]}

è¯·æŸ¥çœ‹æ§åˆ¶å°æ—¥å¿—ä»¥è·å–è¯¦ç»†çš„æ‰§è¡Œæµç¨‹ä¿¡æ¯ã€‚
å…³é”®æ—¥å¿—æ ‡ç­¾:
- [WeatherService]: ç½‘ç»œè¯·æ±‚å’ŒAPIè°ƒç”¨
- [WeatherRepository]: æ•°æ®ç¼“å­˜å’Œé™çº§ç­–ç•¥  
- [WeatherController]: åŸå¸‚ç®¡ç†å’Œæ•°æ®åè°ƒ
- [WeatherHomePage]: UIäº¤äº’å’Œç”¨æˆ·æ“ä½œ
- [CacheStorage]: æ•°æ®æŒä¹…åŒ–
- [LocationService]: å®šä½æœåŠ¡

å¸¸è§é—®é¢˜æ’æŸ¥:
1. ç½‘ç»œè¿æ¥: æŸ¥çœ‹ WeatherService çš„ HTTP è¯·æ±‚æ—¥å¿—
2. æ•°æ®ç¼“å­˜: æŸ¥çœ‹ WeatherRepository çš„ç¼“å­˜ç­–ç•¥æ—¥å¿—
3. åŸå¸‚æ•°æ®: æŸ¥çœ‹ WeatherController çš„åŸå¸‚åŠ è½½æ—¥å¿—
4. UIæ›´æ–°: æŸ¥çœ‹ WeatherHomePage çš„åˆ·æ–°æµç¨‹æ—¥å¿—
=====================================
    `;
  }
}
