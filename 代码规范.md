# ArkTS 开发代码规范与避坑指南

本文档基于项目开发过程中遇到的实际编译错误（Hvigor/ArkTS Compiler Error）整理而成，旨在规范代码编写，避免重复踩坑。

## 1. 类型系统与对象字面量

### 1.1 禁止使用 `as` 断言对象字面量
ArkTS 不支持使用 `as` 关键字将对象字面量断言为某种类型，必须显式声明变量类型。

**❌ 错误写法 (arkts-no-untyped-obj-literals)**
```typescript
// 编译报错：Object literal must correspond to some explicitly declared class or interface
this.logger.info('Tag', 'Msg', { key: 'value' } as Record<string, string>);

// 或者直接传递无类型对象
this.logger.info('Tag', 'Msg', { key: 'value' });
```

**✅ 正确写法**
必须定义接口（Interface）或类型别名（Type Alias），并显式声明变量。

```typescript
// 1. 定义类型
export type LogData = Record<string, string | number | boolean>;

// 2. 显式声明变量
const data: LogData = {
  'key': 'value'
};

// 3. 传递变量
this.logger.info('Tag', 'Msg', data);
```

### 1.2 禁止使用索引签名接口
ArkTS 不支持在接口中使用索引签名（Index Signature），应使用 `Record` 工具类型。

**❌ 错误写法 (arkts-no-indexed-signatures)**
```typescript
interface DataMap {
  [key: string]: string; // 报错
}
```

**✅ 正确写法**
```typescript
type DataMap = Record<string, string>;
```

### 1.3 禁止对字段使用索引访问
不能通过字符串索引访问类的属性，除非该对象明确是 `Record` 类型。

**❌ 错误写法 (arkts-no-props-by-index)**
```typescript
class MyClass {
  prop: string = 'val';
}
const obj = new MyClass();
const val = obj['prop']; // 报错
```

**✅ 正确写法**
直接访问属性，或使用 `Record` 类型。
```typescript
const val = obj.prop;
```

### 1.4 对象字面量必须绑定已声明类型，禁止用字面量充当类型
ArkTS 不允许把对象字面量当作类型声明（arkts-no-obj-literals-as-types），也不允许未绑定类型的对象字面量（arkts-no-untyped-obj-literals）。

**❌ 错误写法**
```typescript
// 直接用对象当类型或未声明类型
type T = { duration: number, curve: Curve }; // 报错
const Animation = { duration: 200, curve: Curve.EaseOut }; // 报错
```

**✅ 正确写法**
```typescript
interface AnimationPreset { duration: number; curve: Curve; }

const ANIMATION_FAST: AnimationPreset = { duration: 200, curve: Curve.EaseOut };
const Animation: { FAST: AnimationPreset } = { FAST: ANIMATION_FAST };
```

### 1.5 线性渐变参数类型必须匹配 `LinearGradientOptions`
`linearGradient` 的 `colors` 必须是 `[ResourceColor, number][]`，不能用 `string[]` 或 `(string|number)[][]`。

**✅ 示例**
```typescript
private static readonly GRADIENT_HEADER: { angle: number; colors: [ResourceColor, number][] } = {
  angle: 180,
  colors: [['rgba(0,0,0,0.35)', 0.0], ['rgba(0,0,0,0)', 1.0]]
};
```

### 1.6 设计系统聚合对象必须先声明接口，再初始化
`DesignSystem` 内的 `Spacing/Colors/FontWeight/IconResources/Icons` 等聚合对象：
1) 先声明接口，包含所有使用到的字段（例如 ColorsDef 要有 `ERROR/SUCCESS/WARNING`）；  
2) 用接口类型初始化对象，禁止裸字面量。

**✅ 示例**
```typescript
interface ColorsDef { WHITE: string; TEXT_PRIMARY: string; ERROR: string; /* ... */ }

static readonly Colors: ColorsDef = {
  WHITE: '#FFFFFF',
  TEXT_PRIMARY: '#FFFFFF',
  ERROR: '#FF453A',
  /* ... */
};
```

## 2. UI 组件开发规范

### 2.1 `build()` 方法内禁止声明局部变量
ArkTS 的 `build()` 方法是声明式 UI 描述，不允许在其中定义局部变量或执行复杂逻辑。

**❌ 错误写法**
```typescript
build() {
  Column() {
    const marginVal = 10; // 报错：Only UI component syntax can be written here
    Text('Hello').margin(marginVal)
  }
}
```

**✅ 正确写法**
将变量提升为组件的属性（Property）或常量。

```typescript
@Component
struct MyComponent {
  private readonly marginVal: number = 10;

  build() {
    Column() {
      Text('Hello').margin(this.marginVal)
    }
  }
}
```

### 2.2 `@StorageProp` 禁止外部初始化
使用 `@StorageProp` 装饰的变量由 `AppStorage` 管理，禁止在父组件实例化子组件时传值。

**❌ 错误写法 (forbidden to specify)**
```typescript
// 子组件
@Component
struct Child {
  @StorageProp('theme') theme: string = 'light';
}

// 父组件
build() {
  Child({ theme: 'dark' }) // 报错：不能在此处初始化 @StorageProp
}
```

**✅ 正确写法**
父组件无需传值，子组件自动从 Storage 获取。
```typescript
build() {
  Child()
}
```

### 2.3 `@Watch` 必须对应存在的方法
`@Watch('methodName')` 装饰器指定的回调方法必须在当前类中存在。

**❌ 错误写法**
```typescript
@State @Watch('onDataChange') data: string = '';
// 缺少 onDataChange 方法定义
```

**✅ 正确写法**
```typescript
@State @Watch('onDataChange') data: string = '';

onDataChange() {
  console.info('Data changed');
}
```

### 2.4 Builder/ForEach 传参，不要在 Builder 内声明局部常量
`@Builder` 内同样禁止局部变量。需要的标记通过参数传入或作为成员字段。

**❌ 错误写法**
```typescript
@Builder
renderItem(item: Data) {
  const isToday = ...; // 报错：Only UI component syntax can be written here
  Text(isToday ? '今天' : item.day)
}
```

**✅ 正确写法**
```typescript
List() {
  ForEach(data, (item, index) => {
    ListItem() { this.renderItem(item, index === 0) }
  })
}

@Builder
renderItem(item: Data, isToday: boolean) {
  Text(isToday ? '今天' : item.day)
}
```

## 3. API 使用与兼容性

### 3.1 `deviceInfo` API 变更
旧版 `deviceInfo` 属性已变更，需使用新属性。

| 旧属性 | 新属性 (推荐) | 说明 |
|---|---|---|
| `deviceInfo.model` | `deviceInfo.productModel` | 设备型号 |
| `deviceInfo.productName` | `deviceInfo.marketName` | 市场名称 |
| - | `deviceInfo.brand` | 品牌 |

### 3.2 路由 Router API
`router.pushUrl` 已更名为 `router.push`，且不再返回 Promise（变为 void）。

**❌ 错误写法**
```typescript
router.pushUrl({ url: '...' }).then(() => { ... });
```

**✅ 正确写法**
```typescript
router.push({ url: '...' }); // 同步调用，无返回值
```

### 3.3 避免重复导入
同一文件中禁止多次导入同一模块，会导致 `Duplicate identifier` 错误。

**❌ 错误写法**
```typescript
import resourceManager from '@ohos.resourceManager';
import resourceManager from '@ohos.resourceManager'; // 报错
```

### 3.4 图标/资源命名与引用
1) `DesignSystem` 中引用的媒体资源必须实际存在于 `entry/src/main/resources/base/media/`，命名与代码完全一致。  
2) 建议为常用图标建立 `IconResources`（Resource）和 `Icons`（Path）两个集合，按接口定义字段，引用时统一从集合读取，避免访问不存在的属性（如 Colors.ERROR 未定义导致 10505001）。  
3) 缺失的指标图标可临时复用已有资源，但依然要在接口中声明并在集合里绑定。

## 4. 最佳实践

1.  **异常处理**：涉及文件操作、网络请求、Storage 操作的代码，务必包裹在 `try-catch` 中，防止应用崩溃。
2.  **资源管理**：使用 `getRawFileDescriptor` 打开资源后，务必在 `finally` 或适当位置调用 `closeRawFileDescriptor`。
3.  **日志规范**：使用封装好的 `DebugLogger`，并定义清晰的 `LogData` 结构，便于调试和排查问题。
