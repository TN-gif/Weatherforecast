# ArkTS 开发代码规范与避坑指南

本文档基于项目开发过程中遇到的实际编译错误（Hvigor/ArkTS Compiler Error）整理而成，旨在规范代码编写，避免重复踩坑。

## 1. 类型系统与对象字面量

### 1.1 禁止使用 `as` 断言对象字面量
ArkTS 不支持使用 `as` 关键字将对象字面量断言为某种类型，必须显式声明变量类型。

**❌ 错误写法 (arkts-no-untyped-obj-literals)**
```typescript
// 编译报错：Object literal must correspond to some explicitly declared class or interface
this.logger.info('Tag', 'Msg', { key: 'value' } as Record<string, string>);

// 或者直接传递无类型对象
this.logger.info('Tag', 'Msg', { key: 'value' });
```

**✅ 正确写法**
必须定义接口（Interface）或类型别名（Type Alias），并显式声明变量。

```typescript
// 1. 定义类型
export type LogData = Record<string, string | number | boolean>;

// 2. 显式声明变量
const data: LogData = {
  'key': 'value'
};

// 3. 传递变量
this.logger.info('Tag', 'Msg', data);
```

### 1.2 禁止使用索引签名接口
ArkTS 不支持在接口中使用索引签名（Index Signature），应使用 `Record` 工具类型。

**❌ 错误写法 (arkts-no-indexed-signatures)**
```typescript
interface DataMap {
  [key: string]: string; // 报错
}
```

**✅ 正确写法**
```typescript
type DataMap = Record<string, string>;
```

### 1.3 禁止对字段使用索引访问
不能通过字符串索引访问类的属性，除非该对象明确是 `Record` 类型。

**❌ 错误写法 (arkts-no-props-by-index)**
```typescript
class MyClass {
  prop: string = 'val';
}
const obj = new MyClass();
const val = obj['prop']; // 报错
```

**✅ 正确写法**
直接访问属性，或使用 `Record` 类型。
```typescript
const val = obj.prop;
```

## 2. UI 组件开发规范

### 2.1 `build()` 方法内禁止声明局部变量
ArkTS 的 `build()` 方法是声明式 UI 描述，不允许在其中定义局部变量或执行复杂逻辑。

**❌ 错误写法**
```typescript
build() {
  Column() {
    const marginVal = 10; // 报错：Only UI component syntax can be written here
    Text('Hello').margin(marginVal)
  }
}
```

**✅ 正确写法**
将变量提升为组件的属性（Property）或常量。

```typescript
@Component
struct MyComponent {
  private readonly marginVal: number = 10;

  build() {
    Column() {
      Text('Hello').margin(this.marginVal)
    }
  }
}
```

### 2.2 `@StorageProp` 禁止外部初始化
使用 `@StorageProp` 装饰的变量由 `AppStorage` 管理，禁止在父组件实例化子组件时传值。

**❌ 错误写法 (forbidden to specify)**
```typescript
// 子组件
@Component
struct Child {
  @StorageProp('theme') theme: string = 'light';
}

// 父组件
build() {
  Child({ theme: 'dark' }) // 报错：不能在此处初始化 @StorageProp
}
```

**✅ 正确写法**
父组件无需传值，子组件自动从 Storage 获取。
```typescript
build() {
  Child()
}
```

### 2.3 `@Watch` 必须对应存在的方法
`@Watch('methodName')` 装饰器指定的回调方法必须在当前类中存在。

**❌ 错误写法**
```typescript
@State @Watch('onDataChange') data: string = '';
// 缺少 onDataChange 方法定义
```

**✅ 正确写法**
```typescript
@State @Watch('onDataChange') data: string = '';

onDataChange() {
  console.info('Data changed');
}
```

## 3. API 使用与兼容性

### 3.1 `deviceInfo` API 变更
旧版 `deviceInfo` 属性已变更，需使用新属性。

| 旧属性 | 新属性 (推荐) | 说明 |
|---|---|---|
| `deviceInfo.model` | `deviceInfo.productModel` | 设备型号 |
| `deviceInfo.productName` | `deviceInfo.marketName` | 市场名称 |
| - | `deviceInfo.brand` | 品牌 |

### 3.2 路由 Router API
`router.pushUrl` 已更名为 `router.push`，且不再返回 Promise（变为 void）。

**❌ 错误写法**
```typescript
router.pushUrl({ url: '...' }).then(() => { ... });
```

**✅ 正确写法**
```typescript
router.push({ url: '...' }); // 同步调用，无返回值
```

### 3.3 避免重复导入
同一文件中禁止多次导入同一模块，会导致 `Duplicate identifier` 错误。

**❌ 错误写法**
```typescript
import resourceManager from '@ohos.resourceManager';
import resourceManager from '@ohos.resourceManager'; // 报错
```

## 4. 最佳实践

1.  **异常处理**：涉及文件操作、网络请求、Storage 操作的代码，务必包裹在 `try-catch` 中，防止应用崩溃。
2.  **资源管理**：使用 `getRawFileDescriptor` 打开资源后，务必在 `finally` 或适当位置调用 `closeRawFileDescriptor`。
3.  **日志规范**：使用封装好的 `DebugLogger`，并定义清晰的 `LogData` 结构，便于调试和排查问题。
