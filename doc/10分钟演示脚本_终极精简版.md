# Aurora Weather - 10分钟演示脚本（终极精简版）

> **核心原则**：只演示实际运行的APP，每句话都是重点，不展示任何HTML图表！

---

## ⏱️ 时间分配（严格10分钟）

| 时间段 | 内容 | 时长 |
|--------|------|------|
| 0:00-0:30 | 开场白 | 30秒 |
| 0:30-4:00 | APP功能演示 | 3分30秒 |
| 4:00-7:00 | 核心代码讲解 | 3分钟 |
| 7:00-9:30 | 创新点总结 | 2分30秒 |
| 9:30-10:00 | 收尾 | 30秒 |

---

## 🎯 第一部分：开场白（30秒）

```
"各位老师好，我展示的是 Aurora Weather 天气预报APP。

三大特色：
1. 时区感知 - 北京白天，洛杉矶自动显示夜景
2. 三层降级 - 缓存→网络→Mock，离线可用
3. MVVM架构 - 生产级代码质量

技术栈：HarmonyOS + ArkTS + 和风天气API
代码规模：74文件，17500行

直接看运行效果。"
```

---

## 📱 第二部分：APP演示（3分30秒）

### 1. 启动与首页（40秒）

**操作**：点击图标启动

**说辞**：
```
"启动后自动GPS定位。

看三点：
1. 动态视频背景 - 根据天气+时间自动选择
2. 玻璃拟态卡片 - 半透明效果
3. 核心信息 - 温度、天气、体感、空气质量

【向下滚动】

详细信息：
- 天气详情网格
- 24小时趋势图
- 7天预报
- 生活建议"
```

### 2. 城市管理（50秒）

**操作**：菜单 → 城市管理 → "+" → 搜索"洛杉矶" → 添加

**说辞**：
```
"城市管理：

【点击加号】搜索'洛杉矶'

关键：添加时自动获取时区信息（UTC-8）
这是后续准确显示昼夜的基础。

【点击添加】

其他功能：
- 长按拖动排序
- 左滑删除
- RDB数据库持久化"
```

### 3. 时区演示 - 核心创新！（1分钟）

**操作**：返回主页 → 滑动到洛杉矶

**说辞**：
```
"核心创新 - 时区感知系统：

【滑动到洛杉矶】

注意背景变化！

从白天阳光 → 夜晚星空

原因：
- 北京现在下午2点（白天）
- 洛杉矶UTC-8，相差16小时
- 洛杉矶当地昨晚10点（夜晚）
- 系统自动计算并切换夜景

【指向日出日落】
日出日落时间是洛杉矶当地时间，不是北京时间。

【滑回北京】
切回北京，背景又变回白天。

这解决了传统APP跨时区显示不准确的问题！"
```

### 4. 刷新与Widget（1分钟）

**操作**：下拉刷新 / 展示Widget

**说辞**：
```
"刷新方式：
1. 下拉刷新
2. 摇一摇刷新 - 有振动反馈
3. 后台自动刷新 - 每30分钟

智能缓存：
- 雷暴10分钟
- 晴天45分钟
- 根据天气类型动态调整

【返回桌面】

Widget功能：
- 显示GPS城市天气
- 主应用刷新后自动同步
- 点击跳转应用"
```

---

## 💻 第三部分：核心代码（3分钟）

### 1. MVVM架构（30秒）

**说辞**：
```
"采用 MVVM + Repository 架构：

【四层结构】
1. UI层 - 只负责展示
2. ViewModel层 - WeatherController管理状态
3. Repository层 - 封装数据访问
4. 数据源层 - 网络、数据库、GPS

优势：职责清晰、便于维护、易扩展"
```

### 2. 核心控制器代码（1分钟）

**展示 WeatherController.ets**

**说辞**：
```
"核心控制器 WeatherController：

【展示 loadAll() 方法】

批量加载天气：

```typescript
async loadAll(forceRefresh) {
  const promises = cities.map(async (city) => {
    // 15秒超时控制
    const snapshot = await Promise.race([
      weatherRepository.loadWeather(city, forceRefresh),
      timeout(15000)
    ]);
    return new CityWeatherState(city, snapshot);
  });
  
  return await Promise.all(promises); // 并行执行
}
```

关键点：
- 并行加载多个城市
- 15秒超时保护
- 单个失败不影响整体"
```

### 3. 三层降级策略（1分钟）

**展示 WeatherRepository.ets**

**说辞**：
```
"数据获取的三层降级：

【展示 loadWeather() 方法】

```typescript
async loadWeather(city, forceRefresh) {
  // 1. 检查缓存
  const cached = await cacheStorage.loadSnapshot(city.id);
  if (cached && !forceRefresh && isCacheValid(cached)) {
    return cached; // 缓存有效，直接返回
  }
  
  try {
    // 2. 网络请求
    const snapshot = await router.fetchWeather(
      city.id, 
      city.coordinates, 
      city.timeZoneOffsetMinutes  // 传递时区信息
    );
    await cacheStorage.saveSnapshot(snapshot);
    return snapshot;
  } catch (error) {
    // 3. 降级方案
    if (cached) return cached;        // 使用过期缓存
    return mockRepository.getSnapshot(); // 使用Mock数据
  }
}
```

价值：
- 网络正常：实时数据
- 网络异常：过期缓存
- 完全离线：Mock数据
- 保证APP始终可用！"
```

### 4. 时区计算代码（30秒）

**说辞**：
```
"时区计算核心逻辑：

```typescript
// 计算城市当地时间
const now = new Date();
const utcTime = now.getTime() + (now.getTimezoneOffset() * 60000);
const cityLocalTime = new Date(utcTime + (timezoneOffsetMinutes * 60000));
const localHours = cityLocalTime.getHours();

// 判断昼夜
const isNight = localHours >= 18 || localHours <= 6;

// 选择主题
const theme = getTheme(weatherKey, isNight);
```

这就是时区感知的核心实现！"
```

---

## 🌟 第四部分：创新总结（2分30秒）

### 1. 三大核心创新（1分30秒）

**说辞**：
```
"总结三大核心创新：

【创新1：时区感知的全球多城市】
- 每个城市独立计算当地时间
- 昼夜背景自动切换
- 日出日落时间准确
→ 解决跨时区显示不准确的行业痛点

【创新2：多源路由 + 智能缓存 + 三层降级】
- 国内外自动选择最优API
- 根据天气类型动态调整缓存
  * 雷暴10分钟
  * 晴天45分钟
- 三层降级保证离线可用
→ 提升数据可靠性和用户体验

【创新3：生产级工程质量】
- MVVM架构，职责清晰
- RDB版本管理，支持平滑升级
- 完整错误处理，不会崩溃
- 详细日志系统
→ 达到生产级应用标准"
```

### 2. 技术亮点（1分钟）

**说辞**：
```
"技术实现亮点：

【架构设计】
✅ MVVM + Repository 分层
✅ 单一数据源原则
✅ 依赖注入便于测试

【代码质量】
✅ 严格遵循ArkTS规范
✅ 完整类型定义
✅ 详细日志和注释

【性能优化】
✅ 并行加载 + 超时控制
✅ 独立滚动器（每个城市独立滚动位置）
✅ ForEach数据版本机制（强制重新渲染）

【用户体验】
✅ 沉浸式视频背景
✅ 玻璃拟态设计
✅ 多种刷新方式
✅ Widget桌面卡片

项目完成度：
- 所有课程要求 ✅
- 多个加分功能 ✅
- 工程化实践 ✅"
```

---

## 🎬 第五部分：收尾（30秒）

**说辞**：
```
"项目总结：

规模：74文件，17500行代码，30+组件

核心价值：
不仅是功能Demo，而是接近生产级的完整应用。

通过这个项目：
- 深入掌握HarmonyOS开发
- 实践MVVM架构设计
- 提升工程化能力

以上是我的演示，谢谢各位老师！"
```

---

## 📝 完整逐字稿（10分钟版本）

### 【0:00-0:30】开场

> "各位老师好，我是XXX，今天展示的是基于HarmonyOS开发的天气预报应用——Aurora Weather。
> 
> 这个项目有三大特色：第一，时区感知系统，北京白天时洛杉矶自动显示夜景；第二，三层数据降级策略，保证离线场景也能使用；第三，采用生产级的MVVM架构。
> 
> 技术栈是HarmonyOS平台，使用ArkTS语言开发。项目规模：74个文件，17500行代码。
> 
> 接下来直接看运行效果。"

### 【0:30-1:10】启动与首页

> "启动应用。
> 
> **【指向屏幕】** 大家看到：
> 
> 1. 应用自动GPS定位，显示'当前位置'
> 2. 背景是动态视频——现在是白天，显示阳光视频
> 3. 所有卡片都是玻璃拟态效果
> 4. 主卡片显示：温度25度、天气描述、体感温度、空气质量
> 
> **【向下滚动】** 下面是详细信息：
> 
> - 天气详情网格：湿度、风速、紫外线、日出日落
> - 24小时趋势图：可以横向滚动
> - 未来7天预报：温度条直观显示温差
> - 生活建议：根据天气自动生成"

### 【1:10-2:00】城市管理

> "**【点击菜单】** 进入城市管理。
> 
> **【点击加号】** 点击加号搜索城市。
> 
> **【输入'洛杉矶'】** 我输入'洛杉矶'，可以看到实时搜索结果。
> 
> 这里用的是Open-Meteo的国际API。如果搜索国内城市，会自动切换到和风天气API。
> 
> **【点击添加】** 点击添加。
> 
> 关键点：添加时系统会自动获取洛杉矶的时区信息（UTC-8），这是后续准确显示昼夜状态的基础。
> 
> 其他功能包括：长按拖动排序、左滑删除、RDB数据库持久化。"

### 【2:00-3:00】时区演示 - 重点！

> "**【返回主页】** 返回主页。
> 
> **【滑动到洛杉矶】** 现在切换到洛杉矶。
> 
> **【重点强调】** 大家注意背景的变化！
> 
> 背景从白天的阳光视频，变成了夜晚的星空视频。
> 
> 为什么？因为：
> 1. 北京现在是下午2点（白天）
> 2. 洛杉矶与北京相差16小时
> 3. 洛杉矶当地时间是昨晚10点（夜晚）
> 4. 系统自动计算并切换了夜景主题
> 
> **【指向日出日落】** 再看日出日落时间，显示的是洛杉矶当地时间，不是北京时间。
> 
> **【滑回北京】** 切回北京，背景又变回白天。
> 
> 这就是时区感知系统的价值——每个城市都显示准确的当地时间和昼夜状态。这是传统天气APP很少做到的！"

### 【3:00-4:00】刷新与Widget

> "**【下拉刷新】** 应用支持多种刷新方式：
> 
> 1. 下拉刷新 - 标准操作
> 2. 摇一摇刷新 - 有振动反馈
> 3. 后台自动刷新 - 每30分钟静默更新
> 
> 智能缓存策略：
> - 雷暴天气10分钟缓存
> - 晴朗天气45分钟缓存
> - 根据天气类型动态调整
> 
> **【返回桌面】** 返回桌面看Widget。
> 
> 桌面Widget功能：
> - 显示GPS定位城市天气
> - 主应用刷新后自动同步
> - 点击跳转到应用
> 
> 跨进程数据同步使用Preferences共享存储。"

### 【4:00-4:30】架构介绍

> "**【切换到代码】** 接下来介绍技术架构。
> 
> 项目采用 MVVM + Repository 分层架构：
> 
> 1. UI层 - WeatherHomePage，只负责展示
> 2. ViewModel层 - WeatherController，管理状态和业务逻辑
> 3. Repository层 - CityRepository、WeatherRepository，封装数据访问
> 4. 数据源层 - 网络服务、RDB存储、GPS定位
> 
> 这种架构的优势是：职责清晰、便于维护、易于扩展。"

### 【4:30-5:30】核心控制器代码

> "**【打开 WeatherController.ets】** 看核心控制器 WeatherController。
> 
> **【定位到 loadAll 方法】** 这是批量加载天气数据的核心方法。
> 
> **【指向代码】** 关键设计点：
> 
> 1. 使用 map 为每个城市创建加载任务
> 2. 使用 Promise.race 添加15秒超时控制
> 3. 使用 Promise.all 并行执行所有任务
> 4. 单个城市失败不影响其他城市
> 
> 这种设计保证了系统的健壮性和响应速度。"

### 【5:30-6:30】三层降级策略

> "**【打开 WeatherRepository.ets】** 看数据仓库 WeatherRepository。
> 
> **【定位到 loadWeather 方法】** 这是数据获取的核心方法，实现了三层降级策略。
> 
> **【指向代码】** 
> 
> 第一层：检查缓存，有效则直接返回
> 第二层：网络请求，注意这里传入了时区信息
> 第三层：降级方案，先用过期缓存，再用Mock数据
> 
> 这种设计的价值：
> - 网络正常时使用实时数据
> - 网络异常时使用过期缓存
> - 完全离线时使用Mock数据
> - 保证APP始终可用！"

### 【6:30-7:00】时区计算代码

> "**【展示时区计算代码】** 时区计算的核心逻辑：
> 
> 1. 获取UTC时间
> 2. 加上城市的时区偏移量
> 3. 得到城市当地时间
> 4. 判断是否夜间（18:00-6:00）
> 5. 选择对应的主题
> 
> 这就是时区感知系统的核心实现！"

### 【7:00-8:30】三大创新点

> "**【切回演示文稿或总结】** 总结三大核心创新：
> 
> **创新1：时区感知的全球多城市系统**
> - 每个城市独立计算当地时间
> - 昼夜背景自动切换
> - 日出日落时间准确
> - 解决了跨时区显示不准确的行业痛点
> 
> **创新2：多源路由 + 智能缓存 + 三层降级**
> - 国内外自动选择最优API
> - 根据天气类型动态调整缓存：雷暴10分钟，晴天45分钟
> - 三层降级保证离线可用
> - 提升了数据可靠性和用户体验
> 
> **创新3：生产级工程质量**
> - MVVM架构，职责清晰
> - RDB版本管理，支持平滑升级
> - 完整错误处理，不会崩溃
> - 详细日志系统
> - 达到了生产级应用的工程标准"

### 【8:30-9:30】技术亮点

> "技术实现亮点：
> 
> **架构设计**：
> - MVVM + Repository 分层
> - 单一数据源原则
> - 依赖注入便于测试
> 
> **代码质量**：
> - 严格遵循ArkTS规范
> - 完整类型定义，无any/unknown
> - 详细日志和注释
> 
> **性能优化**：
> - 并行加载 + 超时控制
> - 独立滚动器，每个城市保持独立滚动位置
> - ForEach数据版本机制，强制重新渲染
> 
> **用户体验**：
> - 沉浸式视频背景
> - 玻璃拟态设计
> - 多种刷新方式
> - Widget桌面卡片
> 
> 项目完成度：
> - 所有课程要求 ✅
> - 多个加分功能 ✅
> - 工程化实践 ✅"

### 【9:30-10:00】收尾

> "项目总结：
> 
> 规模：74个文件，17500行代码，30多个UI组件。
> 
> 核心价值：不仅是功能Demo，而是一个接近生产级的完整应用。
> 
> 通过这个项目，我深入掌握了HarmonyOS开发、实践了MVVM架构设计、提升了工程化能力。
> 
> 以上是我的演示，谢谢各位老师！"

---

## 🎯 关键要点提醒

### 必须强调的3个点

1. **时区感知系统**
   - 这是最大的创新点
   - 演示时一定要让观众看到背景切换
   - 强调"传统APP做不到"

2. **三层降级策略**
   - 保证离线可用
   - 体现工程思维
   - 强调"始终可用"

3. **生产级质量**
   - 不是Demo，是完整应用
   - MVVM架构
   - 完整错误处理

### 演示技巧

1. **操作要慢**
   - 给观众反应时间
   - 重要操作重复一次

2. **重点要重复**
   - 时区切换多说几次
   - 创新点反复强调

3. **时间要把控**
   - 每部分严格按时间
   - 留30秒缓冲

### 应急预案

1. **网络问题**
   - 展示缓存和降级机制
   - 说明"这正好展示了降级策略"

2. **时间不够**
   - 跳过Widget演示
   - 代码只展示降级策略

3. **时间有余**
   - 详细讲解代码
   - 回答观众提问

---

## ✅ 演示前检查清单

### 设备准备
- [ ] 手机已充电
- [ ] APP已安装最新版本
- [ ] 已添加洛杉矶等跨时区城市
- [ ] 网络连接正常
- [ ] 投影连接正常

### 代码准备
- [ ] DevEco Studio已打开
- [ ] 关键文件已打开
- [ ] 字体大小已调整（16-18pt）
- [ ] 关键方法已设置书签

### 内容准备
- [ ] 演示脚本已熟悉
- [ ] 时间分配已记住
- [ ] 关键点已标记
- [ ] 应急预案已准备

---

**文档版本：** v2.0 终极精简版  
**最后更新：** 2024-11-28  
**适用场景：** 10分钟严格限时演示
