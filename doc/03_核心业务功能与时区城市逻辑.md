# 03 核心业务功能与时区城市逻辑

> 汇总自：`CITY_NAME_DISPLAY_IMPROVEMENT.md`、`CITY_MANAGEMENT_VERIFICATION.md`、`GPS_LOCATION_UPDATE_IMPLEMENTATION.md`、`TIMEZONE_INTEGRATION_PLAN.md`、`TIMEZONE_INTEGRATION_COMPLETE.md`、`TIMEZONE_FIX_REPORT.md`、`SUNRISE_SUNSET_FIX_REPORT.md` 等。

本文件聚焦城市管理、定位、时区与日出日落展示等「核心业务逻辑」，梳理从设计方案到最终实现与验证的要点。

---

## 一、城市搜索与名称展示

### 1.1 城市搜索结果结构

- 基于 OpenMeteo / 和风天气地理编码 API，城市结果包含：
  - `id`、`name`、`country`；
  - `adm1`（省级）、`adm2`（市级 / 区级）；
  - `latitude` / `longitude`；
  - 集成后还会包含 `timezone`、`utcOffset` 等字段。

### 1.2 名称显示策略（CITY_NAME_DISPLAY_IMPROVEMENT）

- 设计原则：**「大字简洁，小字详细」**。
  - 大字：仅显示主要城市名（如「唐山」「路南区」）。
  - 小字：显示完整行政区划（如「河北省 唐山市」）。
- 典型处理逻辑：
  - 对中国城市，优先拼接「区 / 市 / 省」形成详细描述；
  - `getCityNameSimple()` 返回城市主名；
  - `getLocationDetail()` 在卡片副标题中展示剩余行政信息。

---

## 二、城市管理与数据存储

### 2.1 城市管理功能验证（CITY_MANAGEMENT_VERIFICATION）

- UI 层面：
  - 城市管理页包含搜索栏、城市列表、空状态页等完整 UI；
  - 支持添加、删除、拖拽排序、状态标记（自动定位、默认城市）。
- 数据层面：
  - 使用 RDB 存储城市信息，引入版本迁移与完整性检查；
  - `CityRepository` 对外提供统一的城市数据访问接口；
  - 内存缓存与数据库保持同步，支持批量更新与事务。

### 2.2 端到端测试与工具

- `CityManagementTester` 封装了一套健壮性与边界条件测试：
  - 数据库迁移、损坏恢复；
  - 城市重复添加、删除默认城市等边界操作；
  - 性能评估（批量操作、排序等）。

---

## 三、GPS 定位与启动体验

### 3.1 启动定位策略（GPS_LOCATION_UPDATE_IMPLEMENTATION）

- 原逻辑问题：
  - `ensureInitialCity()` 只在城市列表为空时定位；
  - 后续启动直接用旧城市列表，导致首屏数据滞后。
- 新逻辑要点：
  - 新增 `updateAutoLocationCity()` 方法：
    - 每次启动都尝试进行 GPS 定位；
    - 获取坐标后再解析城市名；
    - 将自动定位城市更新 / 插入到列表首位。
  - 引入 `ensureDefaultCity()` 作为定位失败兜底（如默认上海）。

### 3.2 刷新与滚动体验

- 强制刷新时：
  - 若传入 `forceRefresh = true`，先调用 `updateAutoLocationCity()`，再刷新其他城市天气。
- 城市切换滚动重置：
  - 为每个城市维持单独的 `Scroller` 实例（`Map<string, Scroller>`）；
  - Swiper 切换页时自动将对应城市滚动位置复位到顶部，避免继承前一个城市的滚动位置。

---

## 四、时区集成方案与实现

### 4.1 问题与方案设计（TIMEZONE_INTEGRATION_PLAN）

- 问题：
  - 初始实现中 `WeatherSnapshot.timezoneOffsetMinutes` 被硬编码为 UTC+8；
  - 所有城市都按北京时间判断白天 / 夜间，导致洛杉矶等城市背景错误。
- 方案：
  - 在城市搜索阶段获取时区信息（如 `zoneName`、`utcOffset`）；
  - 将 UTC 偏移量解析为分钟并保存进 City / WeatherSnapshot；
  - 统一由客户端根据偏移量计算「城市当地时间」。

### 4.2 实际集成与数据流（TIMEZONE_INTEGRATION_COMPLETE）

- `CitySearchService.ets`：
  - 在 `CitySearchResult` 中新增 `timezone`、`utcOffset` 字段；
  - 解析 API 返回的 UTC 偏移（如 `UTC+08:00`）为分钟数；
  - 转换为 City 实体时携带这些信息。
- `QWeatherService.ets`：
  - `fetchWeather()` / `mapToSnapshot()` 接受可选参数 `timezoneOffsetMinutes`；
  - 若提供则使用实际偏移量，否则仍默认 UTC+8；
  - 将偏移量写入 `WeatherSnapshot.timezoneOffsetMinutes`。

### 4.3 与主题切换的衔接（TIMEZONE_FIX_REPORT）

- `WeatherHomePage.ets` 中：
  - `currentState` 的返回类型从 `CityWeatherState | null` 改为与 `isNightTime()` 参数类型兼容；
  - `isNightTime()` 基于 `snapshot.timezoneOffsetMinutes` 计算城市当地小时数；
  - 最终由「基础 themeKey（sunny/rainy/snow）」+「是否夜间」拼接为 `sunny_day` / `sunny_night` 等。

---

## 五、日出日落时间展示修复

### 5.1 问题现象（SUNRISE_SUNSET_FIX_REPORT）

- 某些城市（日例如洛杉矶）日出日落显示为异常格式（如 `"2025-11-"`），而其他城市显示正常；
- 原因：
  - 部分城市仍在使用修复前生成的旧缓存数据；
  - `extractTimeFromIso` 等解析逻辑在演进过程中发生变更。

### 5.2 修复思路

- 修正时间解析函数，对 ISO 字符串进行健壮性检查；
- 对旧缓存数据进行清理或迁移，避免混用新旧格式；
- 在 UI 层面统一采用 `HH:mm` 等用户友好的展示形式。

---

## 六、小结与建议

- 城市管理、定位、时区与日出日落展示构成了应用的「业务骨架」：
  - 城市搜索与名称显示决定了列表与卡片的信息清晰度；
  - 城市管理与 RDB 策略决定了数据长期使用的稳定性；
  - GPS 与刷新策略影响首屏体验与数据新鲜度；
  - 时区与日出日落逻辑保证全球城市视觉表现的正确性。
- 建议后续：
  - 将「城市 / 时区 / 缓存」相关逻辑继续收敛到 Repository 层，尽量减少 UI 层重复判断；
  - 在重要逻辑上补充端到端测试（特别是跨时区场景），确保未来改动不会破坏现有行为。

